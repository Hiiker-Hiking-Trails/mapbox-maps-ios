<%_
  const type = locals.type
  const properties = locals.properties
  const symbol = "point"
  const circle = "circle"
  const fill = "polygon"
  const line = "polyline"
  const supportsClustering = type === symbol
  const isPointAnnotationManager = type === "point"
  const supportedProperties = properties.filter((property) => (!supportsPropertyFunction(property) && !shouldSkipAnnotationProperty(type, property)))
_%>
// This file is generated
import XCTest
@_spi(Experimental) @testable import MapboxMaps

@available(iOS 13.0, *)
final class <%- camelize(type) %>AnnotationGroupTests: XCTestCase {

    var mockAnnotationOrchestratorImpl: MockAnnotationOrchestatorImpl!
    var annotationOrchestrator: AnnotationOrchestrator!

    override func setUp() {
        super.setUp()

        mockAnnotationOrchestratorImpl = MockAnnotationOrchestatorImpl()
        annotationOrchestrator = AnnotationOrchestrator(impl: mockAnnotationOrchestratorImpl)
    }

    override func tearDown() {
        <%_ if ( type === symbol) { _%>
        mockAnnotationOrchestratorImpl.makePointAnnotationManagerStub.reset()
        <%_ } else if ( type === circle ) { _%>
        mockAnnotationOrchestratorImpl.makeCircleAnnotationManagerStub.reset()
        <%_ } else if ( type === line ) { _%>
        mockAnnotationOrchestratorImpl.makePolylineAnnotationManagerStub.reset()
        <%_ } else if ( type === fill ) { _%>
        mockAnnotationOrchestratorImpl.makePolygonAnnotationManagerStub.reset()
        <%_ } _%>
        mockAnnotationOrchestratorImpl.annotationManagersById = [:]
        super.tearDown()
    }

    func testNewAnnotationManager() throws {
        // Given
        let group = <%- camelize(type) %>AnnotationGroup((0...4), id: \.self) { _ in
            <%_ if ( type === symbol) { _%>
            PointAnnotation(coordinate: .random())
            <%_ } else if ( type === circle ) { _%>
            CircleAnnotation(centerCoordinate: .random())
            <%_ } else if ( type === line ) { _%>
            PolylineAnnotation(lineCoordinates: [CLLocationCoordinate2D(latitude: 0, longitude: 0), CLLocationCoordinate2D(latitude: 10, longitude: 10)])
            <%_ } else if ( type === fill ) { _%>
            PolygonAnnotation(
                polygon: .init(outerRing: Ring(coordinates: .random(withLength: 5, generator: CLLocationCoordinate2D.random)))
            )
            <%_ } _%>
        }

        // When
        let erased = group.eraseToAny([0])
        let annotationManagerId = UUID().uuidString
        var annotationIds: [AnyHashable: String] = [:]

        erased.update(annotationOrchestrator, annotationManagerId, &annotationIds)

        // Then
        <%_ if ( type === symbol) { _%>
        let stubbed = mockAnnotationOrchestratorImpl.makePointAnnotationManagerStub.invocations[0]
        let createdAnnotationManager = try XCTUnwrap(stubbed.returnValue as? PointAnnotationManager)
        <%_ } else if ( type === circle ) { _%>
        let stubbed = mockAnnotationOrchestratorImpl.makeCircleAnnotationManagerStub.invocations[0]
        let createdAnnotationManager = try XCTUnwrap(stubbed.returnValue as? CircleAnnotationManager)
        <%_ } else if ( type === line ) { _%>
        let stubbed = mockAnnotationOrchestratorImpl.makePolylineAnnotationManagerStub.invocations[0]
        let createdAnnotationManager = try XCTUnwrap(stubbed.returnValue as? PolylineAnnotationManager)
        <%_ } else if ( type === fill ) { _%>
        let stubbed = mockAnnotationOrchestratorImpl.makePolygonAnnotationManagerStub.invocations[0]
        let createdAnnotationManager = try XCTUnwrap(stubbed.returnValue as? PolygonAnnotationManager)
        <%_ } _%>
        XCTAssertEqual(stubbed.parameters.id, annotationManagerId)
        XCTAssertEqual(createdAnnotationManager.annotations.count, group.data.count)
        XCTAssertTrue(try group.data.allSatisfy {
            let hash = [0, $0]
            let annotationId = try XCTUnwrap(annotationIds[hash])
            return createdAnnotationManager.annotations.contains(where: { $0.id == annotationId })
        })
    }

    func testUpdatingAnnotationManager() {
        let group = <%- camelize(type) %>AnnotationGroup((0...4), id: \.self) { _ in
            <%_ if ( type === symbol) { _%>
            PointAnnotation(coordinate: .random())
            <%_ } else if ( type === circle ) { _%>
            CircleAnnotation(centerCoordinate: .random())
            <%_ } else if ( type === line ) { _%>
            PolylineAnnotation(lineCoordinates: [CLLocationCoordinate2D(latitude: 0, longitude: 0), CLLocationCoordinate2D(latitude: 10, longitude: 10)])
            <%_ } else if ( type === fill ) { _%>
            PolygonAnnotation(
                polygon: .init(outerRing: Ring(coordinates: .random(withLength: 5, generator: CLLocationCoordinate2D.random)))
            )
            <%_ } _%>
        }

        // When
        <%_ if ( type === symbol) { _%>
        let existingAnnotationManager = mockAnnotationOrchestratorImpl.makePointAnnotationManagerStub.defaultReturnValue as! PointAnnotationManager
        <%_ } else if ( type === circle ) { _%>
        let existingAnnotationManager = mockAnnotationOrchestratorImpl.makeCircleAnnotationManagerStub.defaultReturnValue as! CircleAnnotationManager
        <%_ } else if ( type === line ) { _%>
        let existingAnnotationManager = mockAnnotationOrchestratorImpl.makePolylineAnnotationManagerStub.defaultReturnValue as! PolylineAnnotationManager
        <%_ } else if ( type === fill ) { _%>
        let existingAnnotationManager = mockAnnotationOrchestratorImpl.makePolygonAnnotationManagerStub.defaultReturnValue as! PolygonAnnotationManager
        <%_ } _%>
        XCTAssertTrue(existingAnnotationManager.annotations.isEmpty)

        let erased = group.eraseToAny([0])
        let annotationManagerId = UUID().uuidString
        var annotationIds: [AnyHashable: String] = [:]
        mockAnnotationOrchestratorImpl.annotationManagersById[annotationManagerId] = existingAnnotationManager
        erased.update(annotationOrchestrator, annotationManagerId, &annotationIds)

        // Then
        <%_ if ( type === symbol) { _%>
        XCTAssertTrue(mockAnnotationOrchestratorImpl.makePointAnnotationManagerStub.invocations.isEmpty)
        <%_ } else if ( type === circle ) { _%>
        XCTAssertTrue(mockAnnotationOrchestratorImpl.makeCircleAnnotationManagerStub.invocations.isEmpty)
        <%_ } else if ( type === line ) { _%>
        XCTAssertTrue(mockAnnotationOrchestratorImpl.makePolylineAnnotationManagerStub.invocations.isEmpty)
        <%_ } else if ( type === fill ) { _%>
        XCTAssertTrue(mockAnnotationOrchestratorImpl.makePolygonAnnotationManagerStub.invocations.isEmpty)
        <%_ } _%>

        XCTAssertEqual(existingAnnotationManager.annotations.count, group.data.count)
        XCTAssertTrue(try group.data.allSatisfy {
            let hash = [0, $0]
            let annotationId = try XCTUnwrap(annotationIds[hash])
            return existingAnnotationManager.annotations.contains(where: { $0.id == annotationId })
        })
    }

    func testOverrideExistingAnnotationManager() throws {
        // Given
        let group = <%- camelize(type) %>AnnotationGroup((0...4), id: \.self) { _ in
            <%_ if ( type === symbol) { _%>
            PointAnnotation(coordinate: .random())
            <%_ } else if ( type === circle ) { _%>
            CircleAnnotation(centerCoordinate: .random())
            <%_ } else if ( type === line ) { _%>
            PolylineAnnotation(lineCoordinates: [CLLocationCoordinate2D(latitude: 0, longitude: 0), CLLocationCoordinate2D(latitude: 10, longitude: 10)])
            <%_ } else if ( type === fill ) { _%>
            PolygonAnnotation(
                polygon: .init(outerRing: Ring(coordinates: .random(withLength: 5, generator: CLLocationCoordinate2D.random)))
            )
            <%_ } _%>
        }

        // When
        let dummyAnnotationManager = DummyAnnotationManager()
        let annotationManagerId = UUID().uuidString
        mockAnnotationOrchestratorImpl.annotationManagersById[annotationManagerId] = dummyAnnotationManager
        var annotationIds: [AnyHashable: String] = [:]

        let erased = group.eraseToAny([0])
        erased.update(annotationOrchestrator, annotationManagerId, &annotationIds)

        // Then
        <%_ if ( type === symbol) { _%>
        let stubbed = mockAnnotationOrchestratorImpl.makePointAnnotationManagerStub.invocations[0]
        let createdAnnotationManager = try XCTUnwrap(stubbed.returnValue as? PointAnnotationManager)
        <%_ } else if ( type === circle ) { _%>
        let stubbed = mockAnnotationOrchestratorImpl.makeCircleAnnotationManagerStub.invocations[0]
        let createdAnnotationManager = try XCTUnwrap(stubbed.returnValue as? CircleAnnotationManager)
        <%_ } else if ( type === line ) { _%>
        let stubbed = mockAnnotationOrchestratorImpl.makePolylineAnnotationManagerStub.invocations[0]
        let createdAnnotationManager = try XCTUnwrap(stubbed.returnValue as? PolylineAnnotationManager)
        <%_ } else if ( type === fill ) { _%>
        let stubbed = mockAnnotationOrchestratorImpl.makePolygonAnnotationManagerStub.invocations[0]
        let createdAnnotationManager = try XCTUnwrap(stubbed.returnValue as? PolygonAnnotationManager)
        <%_ } _%>
        XCTAssertEqual(stubbed.parameters.id, annotationManagerId)
        XCTAssertEqual(createdAnnotationManager.annotations.count, group.data.count)
        XCTAssertTrue(try group.data.allSatisfy {
            let hash = [0, $0]
            let annotationId = try XCTUnwrap(annotationIds[hash])
            return createdAnnotationManager.annotations.contains(where: { $0.id == annotationId })
        })
    }
}
// End generated file
