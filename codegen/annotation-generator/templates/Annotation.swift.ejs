<%_
  const type = locals.type
  const properties = locals.properties
  const symbol = "point"
  const circle = "circle"
  const fill = "polygon"
  const line = "polyline"
  const supportedProperties = properties.filter((property) => (supportsPropertyFunction(property) && !shouldSkipAnnotationProperty(type, property)))
_%>
// This file is generated.
import Foundation

public struct <%- camelize(type) %>Annotation: Annotation, Equatable {

    /// Identifier for this annotation
    internal(set) public var id: String

    /// The geometry backing this annotation
    public var geometry: Geometry {
        <%_ if (type === symbol) { _%>
        return .point(point)
        <%_ } else if(type === circle) { _%>
        return .point(point)
        <%_ } else if(type === fill) { _%>
        return .polygon(polygon)
        <%_ } else if(type === line) { _%>
        return .lineString(lineString)
        <%_ } _%>
    }

    <%_ if (type === symbol) { _%>
    /// The point backing this annotation
    public var point: Point
    <%_ } else if (type === circle) { _%>
    /// The point backing this annotation
    public var point: Point
    <%_ } else if (type === fill) { _%>
    /// The polygon backing this annotation
    public var polygon: Polygon
    <%_ } else if (type === line) { _%>
    /// The line string backing this annotation
    public var lineString: LineString
    <%_ } _%>

    /// Toggles the annotation's selection state.
    /// If the annotation is deselected, it becomes selected.
    /// If the annotation is selected, it becomes deselected.
    public var isSelected: Bool = false

    /// Property to determine whether annotation can be manually moved around map
    public var isDraggable: Bool = false

    /// Properties associated with the annotation
    public var userInfo: [String: Any]? {
        get { _userInfo?.rawValue as? [String: Any] }
        set {
            let newValue = newValue ?? [:]
            _userInfo = JSONObject(rawValue: newValue)
        }
    }
    private var _userInfo: JSONObject?

    internal var layerProperties: [String: Any] {
        var properties: [String: Any] = [:]
        <%_ for (const property of supportedProperties) { _%>
        properties["<%- property.name %>"] = <%- annotationPropertySwiftTypeToJSONValueConvertor(property) %>
        <%_ } _%>
        return properties
    }

    internal var feature: Feature {
        var feature = Feature(geometry: geometry)
        feature.identifier = .string(id)
        var properties = JSONObject()
        properties["layerProperties"] = JSONValue(rawValue: layerProperties)
        if let _userInfo {
            properties["userInfo"] = .object(_userInfo)
        }
        feature.properties = properties
        return feature
    }

    <%_ if (type === symbol) { _%>

    /// Create a point annotation with a `Point` and an optional identifier.
    public init(id: String = UUID().uuidString, point: Point, isSelected: Bool = false, isDraggable: Bool = false) {
        self.id = id
        self.point = point
        self.isSelected = isSelected
        self.isDraggable = isDraggable
    }

    /// Create a point annotation with a coordinate and an optional identifier
    /// - Parameters:
    ///   - id: Optional identifier for this annotation
    ///   - coordinate: Coordinate where this annotation should be rendered
    public init(id: String = UUID().uuidString, coordinate: CLLocationCoordinate2D, isSelected: Bool = false, isDraggable: Bool = false) {
        let point = Point(coordinate)
        self.init(id: id, point: point, isSelected: isSelected, isDraggable: isDraggable)
    }
    <%_ } else if(type === circle) { _%>

    /// Create a circle annotation with a `Point` and an optional identifier.
    public init(id: String = UUID().uuidString, point: Point, isSelected: Bool = false, isDraggable: Bool = false) {
        self.id = id
        self.point = point
        self.isSelected = isSelected
        self.isDraggable = isDraggable
    }

    /// Create a circle annotation with a center coordinate and an optional identifier
    /// - Parameters:
    ///   - id: Optional identifier for this annotation
    ///   - coordinate: Coordinate where this circle annotation should be centered
    public init(id: String = UUID().uuidString, centerCoordinate: CLLocationCoordinate2D, isSelected: Bool = false, isDraggable: Bool = false) {
        let point = Point(centerCoordinate)
        self.init(id: id, point: point, isSelected: isSelected, isDraggable: isDraggable)
    }
    <%_ } else if(type === fill) { _%>

    /// Create a polygon annotation with a `Polygon` and an optional identifier.
    public init(id: String = UUID().uuidString, polygon: Polygon, isSelected: Bool = false, isDraggable: Bool = false) {
        self.id = id
        self.polygon = polygon
        self.isSelected = isSelected
        self.isDraggable = isDraggable
    }
    <%_ } else if(type === line) { _%>

    /// Create a polyline annotation with a `LineString` and an optional identifier.
    public init(id: String = UUID().uuidString, lineString: LineString, isSelected: Bool = false, isDraggable: Bool = false) {
        self.id = id
        self.lineString = lineString
        self.isSelected = isSelected
        self.isDraggable = isDraggable
    }

    /// Create a polyline annotation with an array of coordinates and an optional identifier.
    public init(id: String = UUID().uuidString, lineCoordinates: [CLLocationCoordinate2D], isSelected: Bool = false, isDraggable: Bool = false) {
        let lineString = LineString(lineCoordinates)
        self.init(id: id, lineString: lineString, isSelected: isSelected, isDraggable: isDraggable)
    }
    <%_ } _%>

    // MARK: - Style Properties -
    <%_ for (const property of properties) { _%>
    <%_ if (supportsPropertyFunction(property) && !shouldSkipAnnotationProperty(type, property)) { _%>

    /// <%- markdownFriendlyDoc(property) %>
    public var <%- camelizeWithLeadingLowercase(property.name) %>: <%- propertySwiftType(property) %>?
    <%_ } _%>
    <%_ } _%>

    <%_ if (type === symbol) { _%>
    // MARK: - Image Convenience -

    public var image: Image? {
        didSet {
            self.iconImage = image?.name
        }
    }
    <%_ } _%>
}

@_spi(Experimental) extension <%- camelize(type) %>Annotation {
    <%_ for (const property of properties) { _%>
    <%_ if (supportsPropertyFunction(property) && !shouldSkipAnnotationProperty(type, property)) { _%>

    /// <%- markdownFriendlyDoc(property) %>
    public func <%- camelizeWithLeadingLowercase(property.name) %>(_ newValue: <%- propertySwiftType(property) %>) -> Self {
        with(self, setter(\.<%- camelizeWithLeadingLowercase(property.name) %>, newValue))
    }
    <%_ } _%>
    <%_ } _%>

    <%_ if (type === symbol) { _%>
    public func image(_ image: Image?) -> Self {
        with(self, setter(\.image, image))
    }
    <%_ } _%>
}

// End of generated file.
