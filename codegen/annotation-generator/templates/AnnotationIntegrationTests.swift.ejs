<%_
  const type = locals.type
  const originalType = locals.orignalType
  const properties = locals.properties

  const expectedExpressionValue = function expectedExpressionValue(property, indentAmount) {
    return indent(indentAmount)(include('ExpectedExpression.swift.ejs', { "property": property })).trim();
  }

  const annotationLocal = function annotationLocal() {
    return indent(8)(include('AnnotationLocal.swift.ejs', { "annotationType": type, "declarationKeyword": "var" })).trim();
  }
_%>
// This file is generated
import XCTest
@testable import MapboxMaps

final class <%- camelize(type) %>AnnotationIntegrationTests: MapViewIntegrationTestCase {

    var manager: <%- camelize(type) %>AnnotationManager!

    override func setUpWithError() throws {
        try super.setUpWithError()
        manager = mapView.annotations.make<%- camelize(type) %>AnnotationManager()
    }

    override func tearDownWithError() throws {
        manager = nil
        try super.tearDownWithError()
    }

    internal func testSourceAndLayerSetup() throws {
        XCTAssertTrue(style.layerExists(withId: manager.layerId))
        XCTAssertTrue(try style.isPersistentLayer(id: manager.layerId),
                      "The layer with id \(manager.layerId) should be persistent.")
        XCTAssertTrue(style.sourceExists(withId: manager.sourceId))
    }

    func testSourceAndLayerRemovedUponDestroy() {
        manager.destroy()

        XCTAssertFalse(style.allLayerIdentifiers.map { $0.id }.contains(manager.layerId))
        XCTAssertFalse(style.allSourceIdentifiers.map { $0.id }.contains(manager.sourceId))
    }

    func testCreatingSecondAnnotationManagerWithTheSameId() throws {
        let secondAnnotationManager = mapView.annotations.make<%- camelize(type) %>AnnotationManager(id: manager.id)

        XCTAssertTrue(mapView.annotations.annotationManagersById[manager.id] === secondAnnotationManager)
    }

    func testSynchronizesAnnotationsEventually() throws {
        <%- annotationLocal() %>
        annotation.<%- camelizeWithLeadingLowercase(testPropertyForType(type).name) %> = 10

        manager.annotations.append(annotation)

        expectation(for: NSPredicate(block: { (_, _) in
            guard let layer = try? self.style.layer(withId: self.manager.layerId, type: <%- camelize(originalType) %>Layer.self) else {
                return false
            }
            return layer.<%- camelizeWithLeadingLowercase(testPropertyForType(type).name) %> == <%- expectedExpressionValue(testPropertyForType(type), 12) %>
        }), evaluatedWith: nil, handler: nil)

        waitForExpectations(timeout: 2, handler: nil)
    }
    <%_ for (const property of properties) { _%>
    <%_ if (!supportsPropertyFunction(property) && !shouldSkipAnnotationProperty(type, property)) { _%>

    func test<%- camelize(property.name) -%>() throws {
        // Test that the setter and getter work
        let value = <%- randomElement(property) %>
        manager.<%- camelizeWithLeadingLowercase(property.name) -%> = value
        XCTAssertEqual(manager.<%- camelizeWithLeadingLowercase(property.name) -%>, value)

        // Test that the value is synced to the layer
        manager.syncSourceAndLayerIfNeeded()
        var layer = try style.layer(withId: self.manager.layerId, type: <%- camelize(originalType) %>Layer.self)
        if case .constant(let actualValue) = layer.<%- camelizeWithLeadingLowercase(property.name) -%> {
            <%- assertions(property) %>
        } else {
            XCTFail("Expected constant")
        }

        // Test that the property can be reset to nil
        manager.<%- camelizeWithLeadingLowercase(property.name) -%> = nil
        XCTAssertNil(manager.<%- camelizeWithLeadingLowercase(property.name) -%>)

        // Verify that when the property is reset to nil,
        // the layer is returned to the default value
        manager.syncSourceAndLayerIfNeeded()
        layer = try style.layer(withId: self.manager.layerId, type: <%- camelize(originalType) %>Layer.self)
        XCTAssertEqual(layer.<%- camelizeWithLeadingLowercase(property.name) -%>, <%- defaultValueConstant(property, originalType) -%>)
    }
    <%_ } _%>
    <%_ } _%>
    <%_ for (const property of properties) { _%>
    <%_ if (supportsPropertyFunction(property) && !shouldSkipAnnotationProperty(type, property)) { _%>

    func test<%- camelize(property.name) -%>() throws {
        <%- annotationLocal() %>
        // Test that the setter and getter work
        let value = <%- randomElement(property) %>
        annotation.<%- camelizeWithLeadingLowercase(property.name) -%> = value
        XCTAssertEqual(annotation.<%- camelizeWithLeadingLowercase(property.name) -%>, value)

        manager.annotations = [annotation]

        // Test that the value is synced to the layer
        manager.syncSourceAndLayerIfNeeded()
        var layer = try style.layer(withId: self.manager.layerId, type: <%- camelize(originalType) %>Layer.self)
        XCTAssertEqual(layer.<%- camelizeWithLeadingLowercase(property.name) -%>, <%- expectedExpressionValue(property, 12) %>)

        // Test that the property can be reset to nil
        annotation.<%- camelizeWithLeadingLowercase(property.name) -%> = nil
        XCTAssertNil(annotation.<%- camelizeWithLeadingLowercase(property.name) -%>)

        manager.annotations = [annotation]

        // Verify that when the property is reset to nil,
        // the layer is returned to the default value
        manager.syncSourceAndLayerIfNeeded()
        layer = try style.layer(withId: self.manager.layerId, type: <%- camelize(originalType) %>Layer.self)
        XCTAssertEqual(layer.<%- camelizeWithLeadingLowercase(property.name) -%>, <%- defaultValueConstant(property, originalType) -%>)
    }
    <%_ } _%>
    <%_ } _%>
}

// End of generated file
