<%_
  const type = locals.type
  const originalType = locals.orignalType
  const properties = locals.properties

  const expectedExpressionValue = function expectedExpressionValue(property, indentAmount) {
    return indent(indentAmount)(include('ExpectedExpression.swift.ejs', { "property": property })).trim();
  }

  const annotationLocal = function annotationLocal() {
    return indent(8)(include('AnnotationLocal.swift.ejs', { "annotationType": type, "declarationKeyword": "var" })).trim();
  }
_%>
// This file is generated
import XCTest
@testable import MapboxMaps

final class <%- camelize(type) %>AnnotationIntegrationTests: MapViewIntegrationTestCase {

    var manager: <%- camelize(type) %>AnnotationManager!

    override func setUpWithError() throws {
        try super.setUpWithError()
        manager = mapView.annotations.make<%- camelize(type) %>AnnotationManager()
    }

    override func tearDownWithError() throws {
        manager = nil
        try super.tearDownWithError()
    }

    internal func testSourceAndLayerSetup() throws {
        XCTAssertTrue(style.layerExists(withId: manager.layerId))
        XCTAssertTrue(try style.isPersistentLayer(id: manager.layerId),
                      "The layer with id \(manager.layerId) should be persistent.")
        XCTAssertTrue(style.sourceExists(withId: manager.sourceId))
    }

    func testSourceAndLayerRemovedUponDestroy() {
        manager.destroy()

        XCTAssertFalse(style.allLayerIdentifiers.map { $0.id }.contains(manager.layerId))
        XCTAssertFalse(style.allSourceIdentifiers.map { $0.id }.contains(manager.sourceId))
    }

    func testCreatingSecondAnnotationManagerWithTheSameId() throws {
        let secondAnnotationManager = mapView.annotations.make<%- camelize(type) %>AnnotationManager(id: manager.id)

        XCTAssertTrue(mapView.annotations.annotationManagersById[manager.id] === secondAnnotationManager)
    }

    func testSynchronizesAnnotationsEventually() throws {
        <%- annotationLocal() %>
        annotation.<%- camelizeWithLeadingLowercase(testPropertyForType(type).name) %> = 10

        manager.annotations.append(annotation)

        expectation(for: NSPredicate(block: { (_, _) in
            guard let layer = try? self.style.layer(withId: self.manager.layerId, type: <%- camelize(originalType) %>Layer.self) else {
                return false
            }
            return layer.<%- camelizeWithLeadingLowercase(testPropertyForType(type).name) %> == <%- expectedExpressionValue(testPropertyForType(type), 12) %>
        }), evaluatedWith: nil, handler: nil)

        waitForExpectations(timeout: 2, handler: nil)
    }
    <%_ for (const property of properties) { _%>
    <%_ if (!supportsPropertyFunction(property) && !shouldSkipAnnotationProperty(type, property)) { _%>

    func test<%- camelize(property.name) -%>() throws {
        // Test that the setter and getter work
        let value = <%- randomElement(property) %>
        manager.<%- camelizeWithLeadingLowercase(property.name) -%> = value
        XCTAssertEqual(manager.<%- camelizeWithLeadingLowercase(property.name) -%>, value)

        // Test that the value is synced to the layer
        manager.syncSourceAndLayerIfNeeded()
        var layer = try style.layer(withId: self.manager.layerId, type: <%- camelize(originalType) %>Layer.self)
        if case .constant(let actualValue) = layer.<%- camelizeWithLeadingLowercase(property.name) -%> {
            <%- assertions(property) %>
        } else {
            XCTFail("Expected constant")
        }

        // Test that the property can be reset to nil
        manager.<%- camelizeWithLeadingLowercase(property.name) -%> = nil
        XCTAssertNil(manager.<%- camelizeWithLeadingLowercase(property.name) -%>)

        // Verify that when the property is reset to nil,
        // the layer is returned to the default value
        manager.syncSourceAndLayerIfNeeded()
        layer = try style.layer(withId: self.manager.layerId, type: <%- camelize(originalType) %>Layer.self)
        XCTAssertEqual(layer.<%- camelizeWithLeadingLowercase(property.name) -%>, <%- defaultValueConstant(property, originalType) -%>)
    }
    <%_ } _%>
    <%_ } _%>
    <%_ for (const property of properties) { _%>
    <%_ if (supportsPropertyFunction(property) && !shouldSkipAnnotationProperty(type, property)) { _%>

    func test<%- camelize(property.name) -%>() throws {
        <%- annotationLocal() %>
        // Test that the setter and getter work
        let value = <%- randomElement(property) %>
        annotation.<%- camelizeWithLeadingLowercase(property.name) -%> = value
        XCTAssertEqual(annotation.<%- camelizeWithLeadingLowercase(property.name) -%>, value)

        manager.annotations = [annotation]

        // Test that the value is synced to the layer
        manager.syncSourceAndLayerIfNeeded()
        var layer = try style.layer(withId: self.manager.layerId, type: <%- camelize(originalType) %>Layer.self)
        XCTAssertEqual(layer.<%- camelizeWithLeadingLowercase(property.name) -%>, <%- expectedExpressionValue(property, 12) %>)

        // Test that the property can be reset to nil
        annotation.<%- camelizeWithLeadingLowercase(property.name) -%> = nil
        XCTAssertNil(annotation.<%- camelizeWithLeadingLowercase(property.name) -%>)

        manager.annotations = [annotation]

        // Verify that when the property is reset to nil,
        // the layer is returned to the default value
        manager.syncSourceAndLayerIfNeeded()
        layer = try style.layer(withId: self.manager.layerId, type: <%- camelize(originalType) %>Layer.self)
        XCTAssertEqual(layer.<%- camelizeWithLeadingLowercase(property.name) -%>, <%- defaultValueConstant(property, originalType) -%>)
    }
    <%_ } _%>
    <%_ } _%>
    <%_ if (type == "point") { %>
    func testImagesAddedToStyleIfNotExist() throws {
        let existingImage = PointAnnotation.Image(image: try XCTUnwrap(UIImage.emptyImage()), name: UUID().uuidString)
        try style.addImage(existingImage.image, id: existingImage.name)

        var annotation1 = PointAnnotation(coordinate: .random())
        annotation1.image = existingImage
        var annotation2 = PointAnnotation(coordinate: .random())
        annotation2.image = .init(image: try XCTUnwrap(UIImage.emptyImage()), name: "test-image-2")
        manager.annotations = [annotation1, annotation2]
        manager.syncSourceAndLayerIfNeeded()

        XCTAssertTrue(style.imageExists(withId: existingImage.name))
        XCTAssertTrue(style.imageExists(withId: "test-image-2"))

        manager.annotations = []
        manager.syncSourceAndLayerIfNeeded()

        // Images added externally will not be removed from Style when PointAnnotationManager is updated.
        XCTAssertTrue(style.imageExists(withId: existingImage.name))
        XCTAssertFalse(style.imageExists(withId: "test-image-2"))
    }

    func testStyleImagesSharedBetweenMultipleManagers() throws {
        let otherManager = mapView.annotations.makePointAnnotationManager()

        let sharedImageID = UUID().uuidString
        let sharedImage = PointAnnotation.Image(image: try XCTUnwrap(UIImage.emptyImage()), name: sharedImageID)

        var pointAnnotation1 = PointAnnotation(coordinate: .random())
        pointAnnotation1.image = sharedImage
        manager.annotations = [pointAnnotation1]

        var pointAnnotation2 = PointAnnotation(coordinate: .random())
        pointAnnotation2.image = sharedImage
        otherManager.annotations = [pointAnnotation2]

        manager.syncSourceAndLayerIfNeeded()
        otherManager.syncSourceAndLayerIfNeeded()

        XCTAssertTrue(style.imageExists(withId: sharedImageID))
        XCTAssertTrue(manager.isUsingStyleImage(sharedImageID))
        XCTAssertTrue(otherManager.isUsingStyleImage(sharedImageID))

        manager.annotations = []
        manager.syncSourceAndLayerIfNeeded()

        XCTAssertTrue(style.imageExists(withId: sharedImageID))
        XCTAssertFalse(manager.isUsingStyleImage(sharedImageID))
        XCTAssertTrue(otherManager.isUsingStyleImage(sharedImageID))

        otherManager.annotations = []
        otherManager.syncSourceAndLayerIfNeeded()

        XCTAssertFalse(style.imageExists(withId: sharedImageID))
        XCTAssertFalse(manager.isUsingStyleImage(sharedImageID))
        XCTAssertFalse(otherManager.isUsingStyleImage(sharedImageID))
    }
    <%_ } -%>
}

// End of generated file
