<%_
  const type = locals.type
  const originalType = locals.orignalType
  const properties = locals.properties

  const annotationLocal = function annotationLocal(declaration) {
    return indent(12)(include('AnnotationLocal.swift.ejs', { "annotationType": type, "declarationKeyword": declaration })).trim();
  }
_%>
// This file is generated
import XCTest
@testable import MapboxMaps

final class <%- camelize(type) %>AnnotationManagerTests: XCTestCase, AnnotationInteractionDelegate {
    var manager: <%- camelize(type) %>AnnotationManager!
    var style: MockStyle!
    var displayLinkCoordinator: MockDisplayLinkCoordinator!
    var id = UUID().uuidString
    var annotations = [<%- camelize(type) %>Annotation]()
    var expectation: XCTestExpectation?
    var delegateAnnotations: [Annotation]?

    override func setUp() {
        super.setUp()

        style = MockStyle()
        displayLinkCoordinator = MockDisplayLinkCoordinator()
        manager = <%- camelize(type) %>AnnotationManager(id: id,
                                          style: style,
                                          layerPosition: nil,
                                          displayLinkCoordinator: displayLinkCoordinator)

        for _ in 0...10 {
            <%- annotationLocal("let") %>
            annotations.append(annotation)
        }
    }

    override func tearDown() {
        style = nil
        displayLinkCoordinator = nil
        manager = nil
        expectation = nil
        delegateAnnotations = nil

        super.tearDown()
    }

    func testSourceSetup() {
        style.addSourceStub.reset()

        _ = <%- camelize(type) %>AnnotationManager(id: id,
                                 style: style,
                                 layerPosition: nil,
                                 displayLinkCoordinator: displayLinkCoordinator)

        XCTAssertEqual(style.addSourceStub.invocations.count, 1)
        XCTAssertEqual(style.addSourceStub.invocations.last?.parameters.source.type, SourceType.geoJson)
        XCTAssertEqual(style.addSourceStub.invocations.last?.parameters.id, manager.id)
    }

    func testAddLayer() {
        style.addSourceStub.reset()
        let initializedManager = <%- camelize(type) %>AnnotationManager(id: id,
                                                         style: style,
                                                         layerPosition: nil,
                                                         displayLinkCoordinator: displayLinkCoordinator)

        XCTAssertEqual(style.addSourceStub.invocations.count, 1)
        XCTAssertEqual(style.addPersistentLayerWithPropertiesStub.invocations.count, 0)
        XCTAssertEqual(style.addPersistentLayerStub.invocations.last?.parameters.layer.type, LayerType.<%- camelizeWithLeadingLowercase(testLayerForType(type).name) %>)
        XCTAssertEqual(style.addPersistentLayerStub.invocations.last?.parameters.layer.id, initializedManager.id)
        XCTAssertEqual(style.addPersistentLayerStub.invocations.last?.parameters.layer.source, initializedManager.sourceId)
        XCTAssertNil(style.addPersistentLayerStub.invocations.last?.parameters.layerPosition)
    }

    func testAddManagerWithDuplicateId() {
        var annotations2 = [<%- camelize(type) %>Annotation]()
        for _ in 0...50 {
            <%- annotationLocal("let") %>
            annotations2.append(annotation)
        }

        manager.annotations = annotations
        let manager2 = <%- camelize(type) %>AnnotationManager(id: manager.id,
                                               style: style,
                                               layerPosition: nil,
                                               displayLinkCoordinator: displayLinkCoordinator)
        manager2.annotations = annotations2

        XCTAssertEqual(manager.annotations.count, 11)
        XCTAssertEqual(manager2.annotations.count, 51)
    }

    func testLayerPositionPassedCorrectly() {
        let manager3 = <%- camelize(type) %>AnnotationManager(id: id,
                                               style: style,
                                               layerPosition: LayerPosition.at(4),
                                               displayLinkCoordinator: displayLinkCoordinator)
        manager3.annotations = annotations

        XCTAssertEqual(style.addPersistentLayerStub.invocations.last?.parameters.layerPosition, LayerPosition.at(4))
    }

    func testDestroyManager() {
        manager.destroy()

        XCTAssertEqual(style.removeLayerStub.invocations.count, 1)
        XCTAssertEqual(style.removeLayerStub.invocations.last?.parameters, manager.id)
        XCTAssertEqual(style.removeSourceStub.invocations.count, 1)
        XCTAssertEqual(style.removeSourceStub.invocations.last?.parameters, manager.id)
    }

    func testDestroyManagerTwice() {
        manager.destroy()
        manager.destroy()

        XCTAssertEqual(style.removeLayerStub.invocations.count, 1)
        XCTAssertEqual(style.removeSourceStub.invocations.count, 1)
    }

    func testSyncSourceAndLayer() {
        manager.annotations = annotations
        manager.syncSourceAndLayerIfNeeded()

        XCTAssertEqual(style.setLayerPropertiesStub.invocations.count, 1)
        XCTAssertEqual(style.updateGeoJSONSourceStub.invocations.count, 1)
    }

    func testDoNotSyncSourceAndLayerWhenNotNeeded() {
        manager.syncSourceAndLayerIfNeeded()

        XCTAssertEqual(style.setLayerPropertiesStub.invocations.count, 0)
        XCTAssertEqual(style.updateGeoJSONSourceStub.invocations.count, 0)
    }

    func testManagerSubscribestoDisplayLinkCoordinator() {
        XCTAssertEqual(displayLinkCoordinator.addStub.invocations.count, 1)
        XCTAssertEqual(displayLinkCoordinator.removeStub.invocations.count, 0)
    }

    func testDestroyManagerRemovesDisplayLinkParticipant() {
        manager.destroy()

        XCTAssertEqual(displayLinkCoordinator.removeStub.invocations.count, 1)
    }

    func testfeatureCollectionPassedtoGeoJSON() {
        var annotations = [<%- camelize(type) %>Annotation]()
        for _ in 0...5 {
            <%- annotationLocal("let") %>
            annotations.append(annotation)
        }
        let featureCollection = FeatureCollection(features: annotations.map(\.feature))

        manager.annotations = annotations
        manager.syncSourceAndLayerIfNeeded()

        XCTAssertEqual(style.updateGeoJSONSourceStub.invocations.count, 1)
        XCTAssertEqual(style.updateGeoJSONSourceStub.invocations.last?.parameters.id, manager.id)
        XCTAssertEqual(style.updateGeoJSONSourceStub.invocations.last?.parameters.geojson, .featureCollection(featureCollection))
    }

    func testHandleQueriedFeatureIdsPassesNotificationToDelegate() throws {
        var annotations = [<%- camelize(type) %>Annotation]()
        for _ in 0...5 {
            <%- annotationLocal("let") %>
            annotations.append(annotation)
        }
        let queriedFeatureIds = [annotations[0].id]
        manager.delegate = self

        manager.annotations = annotations
        manager.handleQueriedFeatureIds(queriedFeatureIds)

        let result = try XCTUnwrap(delegateAnnotations)
        XCTAssertEqual(result[0].id, annotations[0].id)
    }

    func testHandleQueriedFeatureIdsDoesNotPassNotificationToDelegateWhenNoMatch() throws {
        var annotations = [<%- camelize(type) %>Annotation]()
        for _ in 0...5 {
            <%- annotationLocal("let") %>
            annotations.append(annotation)
        }
        let queriedFeatureIds = ["NotAnAnnotationID"]
        manager.delegate = self

        expectation?.isInverted = true
        manager.annotations = annotations
        manager.handleQueriedFeatureIds(queriedFeatureIds)

        XCTAssertNil(delegateAnnotations)
    }

    <%_ for (const property of properties) { _%>
    <%_ if (!supportsPropertyFunction(property) && !shouldSkipAnnotationProperty(type, property)) { _%>
    func testInitial<%- camelize(property.name) %>() {
        let initialValue = manager.<%- camelizeWithLeadingLowercase(property.name) %>
        XCTAssertNil(initialValue)
    }

    func testSet<%- camelize(property.name) %>() {
        let value = <%- randomElement(property) %>
        manager.<%- camelizeWithLeadingLowercase(property.name) -%> = value
        XCTAssertEqual(manager.<%- camelizeWithLeadingLowercase(property.name) -%>, value)

        // test layer and source synced and properties added
        manager.syncSourceAndLayerIfNeeded()
        XCTAssertEqual(style.setLayerPropertiesStub.invocations.count, 1)
        XCTAssertEqual(style.updateGeoJSONSourceStub.invocations.count, 1)
        XCTAssertEqual(style.setLayerPropertiesStub.invocations.last?.parameters.layerId, manager.id)
        <%_ if (property.type === "enum") { _%>
        XCTAssertEqual(style.setLayerPropertiesStub.invocations.last?.parameters.properties["<%- property.name %>"] as! String, value.rawValue)
        <%_ } else if (property.name === "text-font") { _%>
        XCTAssertEqual((style.setLayerPropertiesStub.invocations.last?.parameters.properties["<%- property.name %>"] as! [Any])[1] as! [String], value)
        <%_ } else if (property.name === "text-variable-anchor" || property.name === "text-writing-mode") { _%>
        let valueAsString = value.map { $0.rawValue }
        XCTAssertEqual(style.setLayerPropertiesStub.invocations.last?.parameters.properties["<%- property.name %>"] as! [String], valueAsString)
        <%_ } else { _%>
        XCTAssertEqual(style.setLayerPropertiesStub.invocations.last?.parameters.properties["<%- property.name %>"] as! <%- propertySwiftType(property) %>, value)
        <%_ } _%>
    }

    func test<%- camelize(property.name) %>AnnotationPropertiesAddedWithoutDuplicate() {
        let new<%- camelize(property.name) %>Property = <%- randomElement(property) %>
        let second<%- camelize(property.name) %>Property = <%- randomElement(property) %>

        manager.<%- camelizeWithLeadingLowercase(property.name) %> = new<%- camelize(property.name) %>Property
        manager.syncSourceAndLayerIfNeeded()
        manager.<%- camelizeWithLeadingLowercase(property.name) %> = second<%- camelize(property.name) %>Property
        manager.syncSourceAndLayerIfNeeded()

        XCTAssertEqual(style.setLayerPropertiesStub.invocations.last?.parameters.layerId, manager.id)
        XCTAssertEqual(style.setLayerPropertiesStub.invocations.count, 2)
        <%_ if (property.type === "enum") { _%>
        XCTAssertEqual(style.setLayerPropertiesStub.invocations.last?.parameters.properties["<%- property.name %>"] as! String, second<%- camelize(property.name) %>Property.rawValue)
        <%_ } else if (property.name === "text-font") { _%>
        XCTAssertEqual((style.setLayerPropertiesStub.invocations.last?.parameters.properties["<%- property.name %>"] as! [Any])[1] as! [String], second<%- camelize(property.name) %>Property)
        <%_ } else if (property.name === "text-variable-anchor" || property.name === "text-writing-mode") { _%>
        let valueAsString = second<%- camelize(property.name) %>Property.map { $0.rawValue }
        XCTAssertEqual(style.setLayerPropertiesStub.invocations.last?.parameters.properties["<%- property.name %>"] as! [String], valueAsString)
        <%_ } else { _%>
        XCTAssertEqual(style.setLayerPropertiesStub.invocations.last?.parameters.properties["<%- property.name %>"] as! <%- propertySwiftType(property) %>, second<%- camelize(property.name) %>Property)
        <%_ } _%>
    }

    func testNew<%- camelize(property.name) %>PropertyMergedWithAnnotationProperties() {
        var annotations = [<%- camelize(type) %>Annotation]()
        for _ in 0...5 {
            <%- annotationLocal("var") %>
            <%_ for (const property of properties) { _%>
            <%_ if (supportsPropertyFunction(property) && !shouldSkipAnnotationProperty(type, property)) { _%>
            annotation.<%- camelizeWithLeadingLowercase(property.name) -%> = <%- randomElement(property) %>
            <%_ } _%>
            <%_ } _%>
            annotations.append(annotation)
        }
        let new<%- camelize(property.name) %>Property = <%- randomElement(property) %>

        manager.annotations = annotations
        manager.<%- camelizeWithLeadingLowercase(property.name) %> = new<%- camelize(property.name) %>Property
        manager.syncSourceAndLayerIfNeeded()

        XCTAssertEqual(style.setLayerPropertiesStub.invocations.count, 1)
        XCTAssertEqual(style.setLayerPropertiesStub.invocations.last?.parameters.properties.count, annotations[0].layerProperties.count+1)
        XCTAssertNotNil(style.setLayerPropertiesStub.invocations.last?.parameters.properties["<%- property.name %>"])
    }

    func testSetToNil<%- camelize(property.name) %>() {
        let new<%- camelize(property.name) %>Property = <%- randomElement(property) %>
        let defaultValue = <%- defaultValue(property, originalType) -%>

        manager.<%- camelizeWithLeadingLowercase(property.name) %> = new<%- camelize(property.name) %>Property
        manager.syncSourceAndLayerIfNeeded()
        XCTAssertNotNil(style.setLayerPropertiesStub.invocations.last?.parameters.properties["<%- property.name %>"])

        manager.<%- camelizeWithLeadingLowercase(property.name) -%> = nil
        manager.syncSourceAndLayerIfNeeded()
        XCTAssertNil(manager.<%- camelizeWithLeadingLowercase(property.name) -%>)

        <%_ if (property.type === "enum") { _%>
        XCTAssertEqual(style.setLayerPropertiesStub.invocations.last?.parameters.properties["<%- property.name %>"] as! String, defaultValue)
        <%_ } else { _%>
        XCTAssertEqual(style.setLayerPropertiesStub.invocations.last?.parameters.properties["<%- property.name %>"] as! <%- propertySwiftType(property) %>, defaultValue)
        <%_ } _%>
    }

    <%_ } _%>
    <%_ } _%>
    func annotationManager(_ manager: AnnotationManager, didDetectTappedAnnotations annotations: [Annotation]) {
        self.delegateAnnotations = annotations
        expectation?.fulfill()
        expectation = nil
    }

    <%_ if (type === "point") { _%>
    // Add tests specific to PointAnnotationManager
    func testNewImagesAddedToStyle() {
        // given
        let annotations = (0..<10)
            .map { _ in PointAnnotation.Image(image: UIImage(), name: UUID().uuidString) }
            .map(PointAnnotation.init)

        // when
        manager.annotations = annotations
        manager.syncSourceAndLayerIfNeeded()

        // then
        XCTAssertEqual(style.addImageWithInsetsStub.invocations.count, annotations.count)
        XCTAssertEqual(
            Set(style.addImageWithInsetsStub.invocations.map(\.parameters.id)),
            Set(annotations.compactMap(\.image?.name))
        )
        XCTAssertEqual(
            Set(style.addImageWithInsetsStub.invocations.map(\.parameters.image)),
            Set(annotations.compactMap(\.image?.image))
        )
        XCTAssertEqual(style.removeImageStub.invocations.count, 0)
    }

    func testUnusedImagesRemovedFromStyle() {
        // given
        let unusedAnnotations = 3
        let annotations = (0..<10)
            .map { _ in PointAnnotation.Image(image: UIImage(), name: UUID().uuidString) }
            .map(PointAnnotation.init)
        manager.annotations = annotations
        manager.syncSourceAndLayerIfNeeded()

        // when
        manager.annotations = annotations.suffix(annotations.count - unusedAnnotations)
        manager.syncSourceAndLayerIfNeeded()

        // then
        XCTAssertEqual(style.addImageWithInsetsStub.invocations.count, annotations.count + annotations.count - unusedAnnotations)
        XCTAssertEqual(
            Set(style.addImageWithInsetsStub.invocations.map(\.parameters.id)),
            Set(annotations.compactMap(\.image?.name))
        )
        XCTAssertEqual(
            Set(style.addImageWithInsetsStub.invocations.map(\.parameters.image)),
            Set(annotations.compactMap(\.image?.image))
        )
        XCTAssertEqual(style.removeImageStub.invocations.count, unusedAnnotations)
        XCTAssertEqual(
            Set(style.removeImageStub.invocations.map(\.parameters)),
            Set(annotations.prefix(unusedAnnotations).compactMap(\.image?.name))
        )
    }

    func testAllImagesRemovedFromStyleOnUpdate() {
        // given
        let annotations = (0..<10)
            .map { _ in PointAnnotation.Image(image: UIImage(), name: UUID().uuidString) }
            .map(PointAnnotation.init)
        manager.annotations = annotations
        manager.syncSourceAndLayerIfNeeded()

        // when
        manager.annotations = []
        manager.syncSourceAndLayerIfNeeded()

        // then
        XCTAssertEqual(style.addImageWithInsetsStub.invocations.count, annotations.count)
        XCTAssertEqual(
            Set(style.addImageWithInsetsStub.invocations.map(\.parameters.id)),
            Set(annotations.compactMap(\.image?.name))
        )
        XCTAssertEqual(
            Set(style.addImageWithInsetsStub.invocations.map(\.parameters.image)),
            Set(annotations.compactMap(\.image?.image))
        )
        XCTAssertEqual(style.removeImageStub.invocations.count, annotations.count)
        XCTAssertEqual(
            Set(style.removeImageStub.invocations.map(\.parameters)),
            Set(annotations.compactMap(\.image?.name))
        )
    }

    func testAllImagesRemovedFromStyleOnDestroy() {
        // given
        let annotations = (0..<10)
            .map { _ in PointAnnotation.Image(image: UIImage(), name: UUID().uuidString) }
            .map(PointAnnotation.init)
        manager.annotations = annotations
        manager.syncSourceAndLayerIfNeeded()

        // when
        manager.destroy()

        // then
        XCTAssertEqual(style.removeImageStub.invocations.count, annotations.count)
        XCTAssertEqual(
            Set(style.removeImageStub.invocations.map(\.parameters)),
            Set(annotations.compactMap(\.image?.name))
        )

    }

    // Tests for clustering
    func testInitWithDefaultClusterOptions() {
        style.addSourceStub.reset()
        style.addPersistentLayerStub.reset()
        // given
        let clusterOptions = ClusterOptions()
        var annotations = [PointAnnotation]()
        for _ in 0...500 {
            let annotation = PointAnnotation(coordinate: .random())
            annotations.append(annotation)
        }

        // when
        let pointAnnotationManager = PointAnnotationManager(id: id,
                                  style: style,
                                  layerPosition: nil,
                                  displayLinkCoordinator: displayLinkCoordinator,
                                  clusterOptions: clusterOptions)
        pointAnnotationManager.annotations = annotations

        // then
        XCTAssertEqual(clusterOptions.clusterRadius, 50)
        XCTAssertEqual(clusterOptions.circleRadius, .constant(18))
        XCTAssertEqual(clusterOptions.textColor, .constant(StyleColor(.white)))
        XCTAssertEqual(clusterOptions.textSize, .constant(12))
        XCTAssertEqual(clusterOptions.textField, .expression(Exp(.get) { "point_count" }))
        XCTAssertEqual(clusterOptions.clusterMaxZoom, 14)
        XCTAssertEqual(clusterOptions.colorLevels.description, [(pointCount: 0, clusterColor: StyleColor(.blue))].description)
        XCTAssertNil(clusterOptions.clusterProperties)
        XCTAssertEqual(style.addSourceStub.invocations.count, 1)
        XCTAssertEqual(style.addSourceStub.invocations.last?.parameters.source.type, SourceType.geoJson)
        XCTAssertEqual(style.addSourceStub.invocations.last?.parameters.id, manager.id)
        XCTAssertEqual(style.addPersistentLayerStub.invocations.count, 3) // symbol layer, one cluster layer, one text layer
        XCTAssertNil(style.addPersistentLayerStub.invocations.last?.parameters.layerPosition)
    }

    func testSourceClusterOptions() {
        style.addSourceStub.reset()
        style.addPersistentLayerStub.reset()
        // given
        let testClusterRadius = Double.testSourceValue()
        let testClusterMaxZoom = Double.testSourceValue()
        let testClusterProperties = [String: Expression].testSourceValue()
        let clusterOptions = ClusterOptions(clusterRadius: testClusterRadius,
                                            clusterMaxZoom: testClusterMaxZoom,
                                            clusterProperties: testClusterProperties)
        var annotations = [PointAnnotation]()
        for _ in 0...500 {
            let annotation = PointAnnotation(coordinate: .random())
            annotations.append(annotation)
        }

        // when
        let pointAnnotationManager = PointAnnotationManager(id: id,
                                  style: style,
                                  layerPosition: nil,
                                  displayLinkCoordinator: displayLinkCoordinator,
                                  clusterOptions: clusterOptions)

        pointAnnotationManager.annotations = annotations
        let geoJSONSource = style.addSourceStub.invocations.last?.parameters.source as! GeoJSONSource

        // then
        XCTAssertTrue(geoJSONSource.cluster!)
        XCTAssertEqual(clusterOptions.clusterRadius, testClusterRadius)
        XCTAssertEqual(style.addSourceStub.invocations.count, 1)
        XCTAssertEqual(geoJSONSource.clusterRadius, testClusterRadius)
        XCTAssertEqual(geoJSONSource.clusterMaxZoom, testClusterMaxZoom)
        XCTAssertEqual(geoJSONSource.clusterProperties, testClusterProperties)
    }

    func testCircleLayers() {
        style.addSourceStub.reset()
        style.addPersistentLayerStub.reset()
        // given
        let testCircleRadius = Value<Double>.testConstantValue()
        let clusterOptions = ClusterOptions(circleRadius: testCircleRadius)
        var annotations = [PointAnnotation]()
        for _ in 0...500 {
            let annotation = PointAnnotation(coordinate: .random())
            annotations.append(annotation)
        }

        // when
        let pointAnnotationManager = PointAnnotationManager(id: id,
                                  style: style,
                                  layerPosition: nil,
                                  displayLinkCoordinator: displayLinkCoordinator,
                                  clusterOptions: clusterOptions)
        pointAnnotationManager.annotations = annotations

        // then
        let circleLayerInvocations = style.addPersistentLayerStub.invocations.filter { circleLayer in
            return circleLayer.parameters.layer.type == .circle
        }
        for (index, invocation) in circleLayerInvocations.enumerated() {
            let circleLayer = invocation.parameters.layer as! CircleLayer
            XCTAssertEqual(circleLayer.circleRadius, testCircleRadius)
            XCTAssertEqual(circleLayer.id, "mapbox-iOS-cluster-circle-layer-\(index)")
        }
        XCTAssertEqual(circleLayerInvocations.count, clusterOptions.colorLevels.count)
        XCTAssertEqual(clusterOptions.circleRadius, testCircleRadius)
        XCTAssertEqual(style.addSourceStub.invocations.count, 1)
    }

    func testColorLevels() {
        style.addSourceStub.reset()
        style.addPersistentLayerStub.reset()
        // given
        let testColorLevels = Array.random(withLength: UInt.random(in: 0..<100)) {
            return (pointCount: Int.random(in: 0..<10000), clusterColor: StyleColor.testConstantValue())
        }
        let clusterOptions = ClusterOptions(colorLevels: testColorLevels)
        var annotations = [PointAnnotation]()
        for _ in 0...500 {
            let annotation = PointAnnotation(coordinate: .random())
            annotations.append(annotation)
        }

        // when
        let pointAnnotationManager = PointAnnotationManager(id: id,
                                    style: style,
                                    layerPosition: nil,
                                    displayLinkCoordinator: displayLinkCoordinator,
                                    clusterOptions: clusterOptions)
        pointAnnotationManager.annotations = annotations

        // then
        let circleLayerInvocations = style.addPersistentLayerStub.invocations.filter { circleLayer in
            return circleLayer.parameters.layer.type == .circle
        }

        var expectedExpression: Expression
        for (index, invocation) in circleLayerInvocations.enumerated() {
            let circleLayer = invocation.parameters.layer as! CircleLayer
            if index == 0 {
                expectedExpression = Exp(.all) {
                    Exp(.has) { "point_count" }
                    Exp(.gte) {
                        Exp(.get) { "point_count" }
                        Exp(.toNumber) {
                            testColorLevels[index].pointCount
                        }
                    }
                }
            } else {
                expectedExpression = Exp(.all) {
                    Exp(.has) { "point_count" }
                    Exp(.gte) {
                        Exp(.get) { "point_count" }
                        Exp(.toNumber) {
                            testColorLevels[index].pointCount
                        }
                    }
                    Exp(.lt) {
                        Exp(.get) { "point_count" }
                        Exp(.toNumber) {
                            testColorLevels[index-1].pointCount
                        }
                    }
                }
            }
            XCTAssertEqual(circleLayer.circleColor, .constant(testColorLevels[index].1))
            XCTAssertEqual(circleLayer.filter, expectedExpression)
            XCTAssertEqual(circleLayer.id, "mapbox-iOS-cluster-circle-layer-\(index)")
        }
        XCTAssertEqual(circleLayerInvocations.count, clusterOptions.colorLevels.count)
        XCTAssertEqual(clusterOptions.colorLevels.description, testColorLevels.description)
        XCTAssertEqual(style.addSourceStub.invocations.count, 1)
    }

    func testTextLayers() {
        style.addSourceStub.reset()
        style.addPersistentLayerStub.reset()
        // given
        let testTextColor = Value<StyleColor>.testConstantValue()
        let testTextSize = Value<Double>.testConstantValue()
        let testTextField = Value<String>.testConstantValue()
        let clusterOptions = ClusterOptions(textColor: testTextColor,
                                  textSize: testTextSize,
                                  textField: testTextField)
        var annotations = [PointAnnotation]()
        for _ in 0...500 {
            let annotation = PointAnnotation(coordinate: .random())
            annotations.append(annotation)
        }

        // when
        let pointAnnotationManager = PointAnnotationManager(id: id,
                                  style: style,
                                  layerPosition: nil,
                                  displayLinkCoordinator: displayLinkCoordinator,
                                  clusterOptions: clusterOptions)
        pointAnnotationManager.annotations = annotations

        // then
        let textLayerInvocations = style.addPersistentLayerStub.invocations.filter { symbolLayer in
            return symbolLayer.parameters.layer.id == "mapbox-iOS-cluster-text-layer"
        }
        let textLayer = textLayerInvocations[0].parameters.layer as! SymbolLayer

        XCTAssertEqual(textLayer.textColor, testTextColor)
        XCTAssertEqual(textLayer.textSize, testTextSize)
        XCTAssertEqual(textLayer.textField, testTextField)
        XCTAssertEqual(style.addSourceStub.invocations.count, 1)
    }

    func testSymbolLayers() {
        style.addSourceStub.reset()
        style.addPersistentLayerStub.reset()
        // given
        let clusterOptions = ClusterOptions()
        var annotations = [PointAnnotation]()
        for _ in 0...500 {
            let annotation = PointAnnotation(coordinate: .random())
            annotations.append(annotation)
        }

        // when
        let pointAnnotationManager = PointAnnotationManager(id: id,
                                  style: style,
                                  layerPosition: nil,
                                  displayLinkCoordinator: displayLinkCoordinator,
                                  clusterOptions: clusterOptions)
        pointAnnotationManager.annotations = annotations

        // then
        let symbolLayerInvocations = style.addPersistentLayerStub.invocations.filter { symbolLayer in
            return symbolLayer.parameters.layer.id == id
        }
        let symbolLayer = symbolLayerInvocations[0].parameters.layer as! SymbolLayer

        XCTAssertTrue(symbolLayer.iconAllowOverlap == .constant(true))
        XCTAssertTrue(symbolLayer.textAllowOverlap == .constant(true))
        XCTAssertTrue(symbolLayer.iconIgnorePlacement == .constant(true))
        XCTAssertTrue(symbolLayer.textIgnorePlacement == .constant(true))
        XCTAssertEqual(symbolLayer.source, id)
        XCTAssertEqual(style.addSourceStub.invocations.count, 1)
    }

    func testChangeAnnotations() {
        style.addSourceStub.reset()
        style.addPersistentLayerStub.reset()
        // given
        let clusterOptions = ClusterOptions()
        var annotations = [PointAnnotation]()
        for _ in 0...500 {
            let annotation = PointAnnotation(coordinate: .random())
            annotations.append(annotation)
        }
        var newAnnotations = [PointAnnotation]()
        for _ in 0...100 {
            let annotation = PointAnnotation(coordinate: .random())
            newAnnotations.append(annotation)
        }

        // when
        let pointAnnotationManager = PointAnnotationManager(id: id,
                                  style: style,
                                  layerPosition: nil,
                                  displayLinkCoordinator: displayLinkCoordinator,
                                  clusterOptions: clusterOptions)
        pointAnnotationManager.annotations = annotations
        pointAnnotationManager.syncSourceAndLayerIfNeeded()
        var sourceGeoJSON = style.updateGeoJSONSourceStub.invocations.last?.parameters.geojson
        switch sourceGeoJSON {
        case .featureCollection(let data):
          XCTAssertEqual(data.features.count, 501)
        default:
          XCTFail("GeoJSON did not update correctly")
        }

        // then
        pointAnnotationManager.annotations = newAnnotations
        pointAnnotationManager.syncSourceAndLayerIfNeeded()
        sourceGeoJSON = style.updateGeoJSONSourceStub.invocations.last?.parameters.geojson
        switch sourceGeoJSON {
        case .featureCollection(let data):
          XCTAssertEqual(data.features.count, 101)
        default:
          XCTFail("GeoJSON did not update correctly")
        }
        XCTAssertEqual(style.addSourceStub.invocations.count, 1)
    }
    <%_ } _%>
}

<%_ if (type === "point") { _%>
private extension PointAnnotation {
    init(image: Image) {
        self.init(coordinate: .random())
        self.image = image
    }
}
<%_ } _%>
// End of generated file
