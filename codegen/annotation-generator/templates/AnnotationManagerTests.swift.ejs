<%_
  const type = locals.type
  const originalType = locals.orignalType
  const properties = locals.properties
  const isPointAnnotationManager = type === "point" // check for behaviors/properties which only apply to PointAnnotationManagers
  const symbol = "point"
  const circle = "circle"
  const fill = "polygon"
  const line = "polyline"

  const annotationLocal = function annotationLocal(declaration) {
    return indent(12)(include('AnnotationLocal.swift.ejs', { "annotationType": type, "declarationKeyword": declaration })).trim();
  }
_%>
// This file is generated
import XCTest
@testable import MapboxMaps

final class <%- camelize(type) %>AnnotationManagerTests: XCTestCase, AnnotationInteractionDelegate {
    var manager: <%- camelize(type) %>AnnotationManager!
    var style: MockStyle!
    var displayLinkCoordinator: MockDisplayLinkCoordinator!
    var id = UUID().uuidString
    var annotations = [<%- camelize(type) %>Annotation]()
    var expectation: XCTestExpectation?
    var delegateAnnotations: [Annotation]?
    <%_ if (isPointAnnotationManager) { _%>
    var imagesManager: MockAnnotationImagesManager!
    <%_ } _%>
    <%_ if (type === circle || type === symbol) { _%>
    var offsetPointCalculator: OffsetPointCalculator!
    <%_ } else if ( type === line ) { _%>
    var offsetLineStringCalculator: OffsetLineStringCalculator!
    <%_ } else if ( type === fill ) { _%>
    var offsetPolygonCalculator: OffsetPolygonCalculator!
    <%_ } _%>

    var mapboxMap = MockMapboxMap()

    override func setUp() {
        super.setUp()

        style = MockStyle()
        displayLinkCoordinator = MockDisplayLinkCoordinator()
        <%_ if (isPointAnnotationManager) { _%>
        imagesManager = MockAnnotationImagesManager()
        <%_ } _%>
        <%_ if (type === circle || type === symbol) { _%>
        offsetPointCalculator = OffsetPointCalculator(mapboxMap: mapboxMap)
        <%_ } else if ( type === line ) { _%>
        offsetLineStringCalculator = OffsetLineStringCalculator(mapboxMap: mapboxMap)
        <%_ } else if ( type === fill ) { _%>
        offsetPolygonCalculator = OffsetPolygonCalculator(mapboxMap: mapboxMap)
        <%_ } _%>
        manager = <%- camelize(type) %>AnnotationManager(
            id: id,
            style: style,
            layerPosition: nil,
            displayLinkCoordinator: displayLinkCoordinator,
            <%_ if (isPointAnnotationManager) { _%>
            imagesManager: imagesManager,
            <%_ } _%>
            <%_ if (type === circle || type === symbol) { _%>
            offsetPointCalculator: offsetPointCalculator
            <%_ } else if ( type === line ) { _%>
            offsetLineStringCalculator: offsetLineStringCalculator
            <%_ } else if ( type === fill ) { _%>
            offsetPolygonCalculator: offsetPolygonCalculator
            <%_ } _%>
        )

        for _ in 0...10 {
            <%- annotationLocal("let") %>
            annotations.append(annotation)
        }
    }

    override func tearDown() {
        style = nil
        displayLinkCoordinator = nil
        manager = nil
        expectation = nil
        delegateAnnotations = nil
        <%_ if (isPointAnnotationManager) { _%>
        imagesManager = nil
        <%_ } _%>

        super.tearDown()
    }

    func testSourceSetup() {
        style.addSourceStub.reset()

        _ = <%- camelize(type) %>AnnotationManager(
            id: id,
            style: style,
            layerPosition: nil,
            displayLinkCoordinator: displayLinkCoordinator,
            <%_ if (isPointAnnotationManager) { _%>
            imagesManager: imagesManager,
            <%_ } _%>
            <%_ if (type === circle || type === symbol) { _%>
            offsetPointCalculator: offsetPointCalculator
            <%_ } else if ( type === line ) { _%>
            offsetLineStringCalculator: offsetLineStringCalculator
            <%_ } else if ( type === fill ) { _%>
            offsetPolygonCalculator: offsetPolygonCalculator
            <%_ } _%>
        )

        XCTAssertEqual(style.addSourceStub.invocations.count, 1)
        XCTAssertEqual(style.addSourceStub.invocations.last?.parameters.source.type, SourceType.geoJson)
        XCTAssertEqual(style.addSourceStub.invocations.last?.parameters.source.id, manager.id)
    }

    func testAddLayer() {
        style.addSourceStub.reset()
        let initializedManager = <%- camelize(type) %>AnnotationManager(
            id: id,
            style: style,
            layerPosition: nil,
            displayLinkCoordinator: displayLinkCoordinator,
            <%_ if (isPointAnnotationManager) { _%>
            imagesManager: imagesManager,
            <%_ } _%>
            <%_ if (type === circle || type === symbol) { _%>
            offsetPointCalculator: offsetPointCalculator
            <%_ } else if ( type === line ) { _%>
            offsetLineStringCalculator: offsetLineStringCalculator
            <%_ } else if ( type === fill ) { _%>
            offsetPolygonCalculator: offsetPolygonCalculator
            <%_ } _%>
        )

        XCTAssertEqual(style.addSourceStub.invocations.count, 1)
        XCTAssertEqual(style.addPersistentLayerWithPropertiesStub.invocations.count, 0)
        XCTAssertEqual(style.addPersistentLayerStub.invocations.last?.parameters.layer.type, LayerType.<%- camelizeWithLeadingLowercase(testLayerForType(type).name) %>)
        XCTAssertEqual(style.addPersistentLayerStub.invocations.last?.parameters.layer.id, initializedManager.id)
        XCTAssertEqual(style.addPersistentLayerStub.invocations.last?.parameters.layer.source, initializedManager.sourceId)
        XCTAssertNil(style.addPersistentLayerStub.invocations.last?.parameters.layerPosition)
    }

    func testAddManagerWithDuplicateId() {
        var annotations2 = [<%- camelize(type) %>Annotation]()
        for _ in 0...50 {
            <%- annotationLocal("let") %>
            annotations2.append(annotation)
        }

        manager.annotations = annotations
        let manager2 = <%- camelize(type) %>AnnotationManager(
            id: manager.id,
            style: style,
            layerPosition: nil,
            displayLinkCoordinator: displayLinkCoordinator,
            <%_ if (isPointAnnotationManager) { _%>
            imagesManager: imagesManager,
            <%_ } _%>
            <%_ if (type === circle || type === symbol) { _%>
            offsetPointCalculator: offsetPointCalculator
            <%_ } else if ( type === line ) { _%>
            offsetLineStringCalculator: offsetLineStringCalculator
            <%_ } else if ( type === fill ) { _%>
            offsetPolygonCalculator: offsetPolygonCalculator
            <%_ } _%>
        )
        manager2.annotations = annotations2

        XCTAssertEqual(manager.annotations.count, 11)
        XCTAssertEqual(manager2.annotations.count, 51)
    }

    func testLayerPositionPassedCorrectly() {
        let manager3 = <%- camelize(type) %>AnnotationManager(
            id: id,
            style: style,
            layerPosition: LayerPosition.at(4),
            displayLinkCoordinator: displayLinkCoordinator,
            <%_ if (isPointAnnotationManager) { _%>
            imagesManager: imagesManager,
            <%_ } _%>
            <%_ if (type === circle || type === symbol) { _%>
            offsetPointCalculator: offsetPointCalculator
            <%_ } else if ( type === line ) { _%>
            offsetLineStringCalculator: offsetLineStringCalculator
            <%_ } else if ( type === fill ) { _%>
            offsetPolygonCalculator: offsetPolygonCalculator
            <%_ } _%>
        )
        manager3.annotations = annotations

        XCTAssertEqual(style.addPersistentLayerStub.invocations.last?.parameters.layerPosition, LayerPosition.at(4))
    }

    func testDestroyManager() {
        manager.destroy()

        XCTAssertEqual(style.removeLayerStub.invocations.map(\.parameters), [id + "_drag-layer", id])
        XCTAssertEqual(style.removeSourceStub.invocations.map(\.parameters), [id + "_drag-source", id])
    }

    func testDestroyManagerTwice() {
        manager.destroy()
        XCTAssertEqual(style.removeLayerStub.invocations.map(\.parameters), [id + "_drag-layer", id])
        XCTAssertEqual(style.removeSourceStub.invocations.map(\.parameters), [id + "_drag-source", id])
        style.removeLayerStub.reset()
        style.removeSourceStub.reset()

        manager.destroy()
        XCTAssertTrue(style.removeLayerStub.invocations.isEmpty)
        XCTAssertTrue(style.removeSourceStub.invocations.isEmpty)
    }

    func testSyncSourceAndLayer() {
        manager.annotations = annotations
        manager.syncSourceAndLayerIfNeeded()

        XCTAssertEqual(style.setLayerPropertiesStub.invocations.count, 1)
        XCTAssertEqual(style.updateGeoJSONSourceStub.invocations.count, 1)
    }

    func testDoNotSyncSourceAndLayerWhenNotNeeded() {
        manager.syncSourceAndLayerIfNeeded()

        XCTAssertEqual(style.setLayerPropertiesStub.invocations.count, 0)
        XCTAssertEqual(style.updateGeoJSONSourceStub.invocations.count, 0)
    }

    func testManagerSubscribestoDisplayLinkCoordinator() {
        XCTAssertEqual(displayLinkCoordinator.addStub.invocations.count, 1)
        XCTAssertEqual(displayLinkCoordinator.removeStub.invocations.count, 0)
    }

    func testDestroyManagerRemovesDisplayLinkParticipant() {
        manager.destroy()

        XCTAssertEqual(displayLinkCoordinator.removeStub.invocations.count, 1)
    }

    func testFeatureCollectionPassedtoGeoJSON() {
        var annotations = [<%- camelize(type) %>Annotation]()
        for _ in 0...5 {
            <%- annotationLocal("let") %>
            annotations.append(annotation)
        }
        let expectedFeatureCollection = FeatureCollection(features: annotations.map(\.feature))

        manager.annotations = annotations
        manager.syncSourceAndLayerIfNeeded()

        XCTAssertEqual(style.updateGeoJSONSourceStub.invocations.count, 1)
        XCTAssertEqual(style.updateGeoJSONSourceStub.invocations.last?.parameters.id, manager.id)
        if case .featureCollection(let collection) = style.updateGeoJSONSourceStub.invocations[0].parameters.geojson {
            XCTAssertTrue(collection.features.allSatisfy(expectedFeatureCollection.features.contains(_:)))
        } else {
            XCTFail("GeoJSON object should be a feature collection")
        }
    }

    func testHandleQueriedFeatureIdsPassesNotificationToDelegate() throws {
        var annotations = [<%- camelize(type) %>Annotation]()
        for _ in 0...5 {
            <%- annotationLocal("let") %>
            annotations.append(annotation)
        }
        let queriedFeatureIds = [annotations[0].id]
        manager.delegate = self

        manager.annotations = annotations
        manager.handleQueriedFeatureIds(queriedFeatureIds)

        let result = try XCTUnwrap(delegateAnnotations)
        XCTAssertEqual(result[0].id, annotations[0].id)
    }

    func testHandleQueriedFeatureIdsDoesNotPassNotificationToDelegateWhenNoMatch() throws {
        var annotations = [<%- camelize(type) %>Annotation]()
        for _ in 0...5 {
            <%- annotationLocal("let") %>
            annotations.append(annotation)
        }
        let queriedFeatureIds = ["NotAnAnnotationID"]
        manager.delegate = self

        expectation?.isInverted = true
        manager.annotations = annotations
        manager.handleQueriedFeatureIds(queriedFeatureIds)

        XCTAssertNil(delegateAnnotations)
    }

    <%_ for (const property of properties) { _%>
    <%_ if (!supportsPropertyFunction(property) && !shouldSkipAnnotationProperty(type, property)) { _%>
    func testInitial<%- camelize(property.name) %>() {
        let initialValue = manager.<%- camelizeWithLeadingLowercase(property.name) %>
        XCTAssertNil(initialValue)
    }

    func testSet<%- camelize(property.name) %>() {
        let value = <%- randomElement(property) %>
        manager.<%- camelizeWithLeadingLowercase(property.name) -%> = value
        XCTAssertEqual(manager.<%- camelizeWithLeadingLowercase(property.name) -%>, value)

        // test layer and source synced and properties added
        manager.syncSourceAndLayerIfNeeded()
        XCTAssertEqual(style.setLayerPropertiesStub.invocations.count, 1)
        XCTAssertEqual(style.updateGeoJSONSourceStub.invocations.count, 1)
        XCTAssertEqual(style.setLayerPropertiesStub.invocations.last?.parameters.layerId, manager.id)
        <%_ if (property.type === "enum") { _%>
        XCTAssertEqual(style.setLayerPropertiesStub.invocations.last?.parameters.properties["<%- property.name %>"] as! String, value.rawValue)
        <%_ } else if (property.name === "text-font") { _%>
        XCTAssertEqual((style.setLayerPropertiesStub.invocations.last?.parameters.properties["<%- property.name %>"] as! [Any])[1] as! [String], value)
        <%_ } else if (property.name === "text-variable-anchor" || property.name === "text-writing-mode") { _%>
        let valueAsString = value.map { $0.rawValue }
        XCTAssertEqual(style.setLayerPropertiesStub.invocations.last?.parameters.properties["<%- property.name %>"] as! [String], valueAsString)
        <%_ } else { _%>
        XCTAssertEqual(style.setLayerPropertiesStub.invocations.last?.parameters.properties["<%- property.name %>"] as! <%- propertySwiftType(property) %>, value)
        <%_ } _%>
    }

    func test<%- camelize(property.name) %>AnnotationPropertiesAddedWithoutDuplicate() {
        let new<%- camelize(property.name) %>Property = <%- randomElement(property) %>
        let second<%- camelize(property.name) %>Property = <%- randomElement(property) %>

        manager.<%- camelizeWithLeadingLowercase(property.name) %> = new<%- camelize(property.name) %>Property
        manager.syncSourceAndLayerIfNeeded()
        manager.<%- camelizeWithLeadingLowercase(property.name) %> = second<%- camelize(property.name) %>Property
        manager.syncSourceAndLayerIfNeeded()

        XCTAssertEqual(style.setLayerPropertiesStub.invocations.last?.parameters.layerId, manager.id)
        XCTAssertEqual(style.setLayerPropertiesStub.invocations.count, 2)
        <%_ if (property.type === "enum") { _%>
        XCTAssertEqual(style.setLayerPropertiesStub.invocations.last?.parameters.properties["<%- property.name %>"] as! String, second<%- camelize(property.name) %>Property.rawValue)
        <%_ } else if (property.name === "text-font") { _%>
        XCTAssertEqual((style.setLayerPropertiesStub.invocations.last?.parameters.properties["<%- property.name %>"] as! [Any])[1] as! [String], second<%- camelize(property.name) %>Property)
        <%_ } else if (property.name === "text-variable-anchor" || property.name === "text-writing-mode") { _%>
        let valueAsString = second<%- camelize(property.name) %>Property.map { $0.rawValue }
        XCTAssertEqual(style.setLayerPropertiesStub.invocations.last?.parameters.properties["<%- property.name %>"] as! [String], valueAsString)
        <%_ } else { _%>
        XCTAssertEqual(style.setLayerPropertiesStub.invocations.last?.parameters.properties["<%- property.name %>"] as! <%- propertySwiftType(property) %>, second<%- camelize(property.name) %>Property)
        <%_ } _%>
    }

    func testNew<%- camelize(property.name) %>PropertyMergedWithAnnotationProperties() {
        var annotations = [<%- camelize(type) %>Annotation]()
        for _ in 0...5 {
            <%- annotationLocal("var") %>
            <%_ for (const property of properties) { _%>
            <%_ if (supportsPropertyFunction(property) && !shouldSkipAnnotationProperty(type, property)) { _%>
            annotation.<%- camelizeWithLeadingLowercase(property.name) -%> = <%- randomElement(property) %>
            <%_ } _%>
            <%_ } _%>
            annotations.append(annotation)
        }
        let new<%- camelize(property.name) %>Property = <%- randomElement(property) %>

        manager.annotations = annotations
        manager.<%- camelizeWithLeadingLowercase(property.name) %> = new<%- camelize(property.name) %>Property
        manager.syncSourceAndLayerIfNeeded()

        XCTAssertEqual(style.setLayerPropertiesStub.invocations.count, 1)
        XCTAssertEqual(style.setLayerPropertiesStub.invocations.last?.parameters.properties.count, annotations[0].layerProperties.count+1)
        XCTAssertNotNil(style.setLayerPropertiesStub.invocations.last?.parameters.properties["<%- property.name %>"])
    }

    func testSetToNil<%- camelize(property.name) %>() {
        let new<%- camelize(property.name) %>Property = <%- randomElement(property) %>
        let defaultValue = <%- defaultValue(property, originalType) -%>

        manager.<%- camelizeWithLeadingLowercase(property.name) %> = new<%- camelize(property.name) %>Property
        manager.syncSourceAndLayerIfNeeded()
        XCTAssertNotNil(style.setLayerPropertiesStub.invocations.last?.parameters.properties["<%- property.name %>"])

        manager.<%- camelizeWithLeadingLowercase(property.name) -%> = nil
        manager.syncSourceAndLayerIfNeeded()
        XCTAssertNil(manager.<%- camelizeWithLeadingLowercase(property.name) -%>)

        <%_ if (property.type === "enum") { _%>
        XCTAssertEqual(style.setLayerPropertiesStub.invocations.last?.parameters.properties["<%- property.name %>"] as! String, defaultValue)
        <%_ } else { _%>
        XCTAssertEqual(style.setLayerPropertiesStub.invocations.last?.parameters.properties["<%- property.name %>"] as! <%- propertySwiftType(property) %>, defaultValue)
        <%_ } _%>
    }

    <%_ } _%>
    <%_ } _%>
    func annotationManager(_ manager: AnnotationManager, didDetectTappedAnnotations annotations: [Annotation]) {
        self.delegateAnnotations = annotations
        expectation?.fulfill()
        expectation = nil
    }

    <%_ if (isPointAnnotationManager) { _%>
    // Add tests specific to PointAnnotationManager
    func testNewImagesAddedToStyle() {
        // given
        let annotations = (0..<10)
            .map { _ in PointAnnotation.Image(image: UIImage(), name: UUID().uuidString) }
            .map(PointAnnotation.init)

        // when
        manager.annotations = annotations
        manager.syncSourceAndLayerIfNeeded()

        // then
        XCTAssertEqual(imagesManager.addImageStub.invocations.count, annotations.count)
        XCTAssertEqual(
            Set(imagesManager.addImageStub.invocations.map(\.parameters.id)),
            Set(annotations.compactMap(\.image?.name))
        )
        XCTAssertEqual(
            Set(imagesManager.addImageStub.invocations.map(\.parameters.image)),
            Set(annotations.compactMap(\.image?.image))
        )
        XCTAssertEqual(imagesManager.removeImageStub.invocations.count, 0)
        XCTAssertTrue(annotations.compactMap(\.image?.name).allSatisfy(manager.isUsingStyleImage(_:)))
    }

    func testUnusedImagesRemovedFromStyle() {
        // given
        let allAnnotations = Array.random(withLength: 10) {
            PointAnnotation(image: .init(image: UIImage(), name: UUID().uuidString))
        }
        manager.annotations = allAnnotations
        manager.syncSourceAndLayerIfNeeded()
        imagesManager.addImageStub.reset()
        XCTAssertTrue(allAnnotations.compactMap(\.image?.name).allSatisfy(manager.isUsingStyleImage(_:)))

        // when
        let (unusedAnnotations, remainingAnnotations) = (allAnnotations[0..<3], allAnnotations[3...])
        manager.annotations = Array(remainingAnnotations)
        manager.syncSourceAndLayerIfNeeded()

        // then
        XCTAssertEqual(imagesManager.addImageStub.invocations.count, remainingAnnotations.count)
        XCTAssertEqual(
            Set(imagesManager.addImageStub.invocations.map(\.parameters.id)),
            Set(remainingAnnotations.compactMap(\.image?.name))
        )
        XCTAssertEqual(
            Set(imagesManager.addImageStub.invocations.map(\.parameters.image)),
            Set(remainingAnnotations.compactMap(\.image?.image))
        )
        XCTAssertEqual(imagesManager.removeImageStub.invocations.count, unusedAnnotations.count)
        XCTAssertEqual(
            Set(imagesManager.removeImageStub.invocations.map(\.parameters)),
            Set(unusedAnnotations.compactMap(\.image?.name))
        )
        XCTAssertTrue(remainingAnnotations.compactMap(\.image?.name).allSatisfy(manager.isUsingStyleImage(_:)))
        XCTAssertTrue(unusedAnnotations.compactMap(\.image?.name).filter(manager.isUsingStyleImage(_:)).isEmpty)
    }

    func testAllImagesRemovedFromStyleOnUpdate() {
        // given
        let annotations = (0..<10)
            .map { _ in PointAnnotation.Image(image: UIImage(), name: UUID().uuidString) }
            .map(PointAnnotation.init)
        manager.annotations = annotations
        manager.syncSourceAndLayerIfNeeded()

        // when
        manager.annotations = []
        manager.syncSourceAndLayerIfNeeded()

        // then
        XCTAssertEqual(imagesManager.addImageStub.invocations.count, annotations.count)
        XCTAssertEqual(
            Set(imagesManager.addImageStub.invocations.map(\.parameters.id)),
            Set(annotations.compactMap(\.image?.name))
        )
        XCTAssertEqual(
            Set(imagesManager.addImageStub.invocations.map(\.parameters.image)),
            Set(annotations.compactMap(\.image?.image))
        )
        XCTAssertEqual(imagesManager.removeImageStub.invocations.count, annotations.count)
        XCTAssertEqual(
            Set(imagesManager.removeImageStub.invocations.map(\.parameters)),
            Set(annotations.compactMap(\.image?.name))
        )
        XCTAssertTrue(annotations.compactMap(\.image?.name).filter(manager.isUsingStyleImage(_:)).isEmpty)
    }

    func testAllImagesRemovedFromStyleOnDestroy() {
        // given
        let annotations = (0..<10)
            .map { _ in PointAnnotation.Image(image: UIImage(), name: UUID().uuidString) }
            .map(PointAnnotation.init)
        manager.annotations = annotations
        manager.syncSourceAndLayerIfNeeded()

        // when
        manager.destroy()

        // then
        XCTAssertEqual(imagesManager.removeImageStub.invocations.count, annotations.count)
        XCTAssertEqual(
            Set(imagesManager.removeImageStub.invocations.map(\.parameters)),
            Set(annotations.compactMap(\.image?.name))
        )
        XCTAssertTrue(annotations.compactMap(\.image?.name).filter(manager.isUsingStyleImage(_:)).isEmpty)
    }

    // Tests for clustering
    func testInitWithDefaultClusterOptions() {
        style.addSourceStub.reset()
        style.addPersistentLayerStub.reset()
        // given
        let clusterOptions = ClusterOptions()
        var annotations = [PointAnnotation]()
        for _ in 0...500 {
            let annotation = PointAnnotation(coordinate: .random(), isSelected: false, isDraggable: false)
            annotations.append(annotation)
        }

        // when
        let pointAnnotationManager = PointAnnotationManager(
            id: id,
            style: style,
            layerPosition: nil,
            displayLinkCoordinator: displayLinkCoordinator,
            clusterOptions: clusterOptions,
            imagesManager: imagesManager,
            <%_ if (type === circle || type === symbol) { _%>
            offsetPointCalculator: offsetPointCalculator
            <%_ } else if ( type === line ) { _%>
            offsetLineStringCalculator: offsetLineStringCalculator
            <%_ } else if ( type === fill ) { _%>
            offsetPolygonCalculator: offsetPolygonCalculator
            <%_ } _%>
        )
        pointAnnotationManager.annotations = annotations

        // then
        XCTAssertEqual(clusterOptions.clusterRadius, 50)
        XCTAssertEqual(clusterOptions.circleRadius, .constant(18))
        XCTAssertEqual(clusterOptions.circleColor, .constant(StyleColor(.black)))
        XCTAssertEqual(clusterOptions.textColor, .constant(StyleColor(.white)))
        XCTAssertEqual(clusterOptions.textSize, .constant(12))
        XCTAssertEqual(clusterOptions.textField, .expression(Exp(.get) { "point_count" }))
        XCTAssertEqual(clusterOptions.clusterMaxZoom, 14)
        XCTAssertNil(clusterOptions.clusterProperties)
        XCTAssertEqual(style.addSourceStub.invocations.count, 1)
        XCTAssertEqual(style.addSourceStub.invocations.last?.parameters.source.type, SourceType.geoJson)
        XCTAssertEqual(style.addSourceStub.invocations.last?.parameters.source.id, manager.id)
        XCTAssertEqual(style.addPersistentLayerStub.invocations.count, 3) // symbol layer, one cluster layer, one text layer
        XCTAssertNil(style.addPersistentLayerStub.invocations.last?.parameters.layerPosition)
    }

    func testSourceClusterOptions() {
        style.addSourceStub.reset()
        style.addPersistentLayerStub.reset()
        // given
        let testClusterRadius = Double.testSourceValue()
        let testClusterMaxZoom = Double.testSourceValue()
        let testClusterProperties = [String: Expression].testSourceValue()
        let clusterOptions = ClusterOptions(clusterRadius: testClusterRadius,
                                            clusterMaxZoom: testClusterMaxZoom,
                                            clusterProperties: testClusterProperties)
        var annotations = [PointAnnotation]()
        for _ in 0...500 {
            let annotation = PointAnnotation(coordinate: .random(), isSelected: false, isDraggable: false)
            annotations.append(annotation)
        }

        // when
        let pointAnnotationManager = PointAnnotationManager(
            id: id,
            style: style,
            layerPosition: nil,
            displayLinkCoordinator: displayLinkCoordinator,
            clusterOptions: clusterOptions,
            imagesManager: imagesManager,
            <%_ if (type === circle || type === symbol) { _%>
            offsetPointCalculator: offsetPointCalculator
            <%_ } else if ( type === line ) { _%>
            offsetLineStringCalculator: offsetLineStringCalculator
            <%_ } else if ( type === fill ) { _%>
            offsetPolygonCalculator: offsetPolygonCalculator
            <%_ } _%>
        )
        pointAnnotationManager.annotations = annotations
        let geoJSONSource = style.addSourceStub.invocations.last?.parameters.source as! GeoJSONSource

        // then
        XCTAssertTrue(geoJSONSource.cluster!)
        XCTAssertEqual(clusterOptions.clusterRadius, testClusterRadius)
        XCTAssertEqual(style.addSourceStub.invocations.count, 1)
        XCTAssertEqual(geoJSONSource.clusterRadius, testClusterRadius)
        XCTAssertEqual(geoJSONSource.clusterMaxZoom, testClusterMaxZoom)
        XCTAssertEqual(geoJSONSource.clusterProperties, testClusterProperties)
    }

    func testCircleLayer() {
        style.addSourceStub.reset()
        style.addPersistentLayerStub.reset()
        // given
        let testCircleRadius = Value<Double>.testConstantValue()
        let testCircleColor = Value<StyleColor>.testConstantValue()
        let clusterOptions = ClusterOptions(circleRadius: testCircleRadius,
                                            circleColor: testCircleColor)
        var annotations = [PointAnnotation]()
        for _ in 0...500 {
            let annotation = PointAnnotation(coordinate: .random(), isSelected: false, isDraggable: false)
            annotations.append(annotation)
        }

        // when
        let pointAnnotationManager = PointAnnotationManager(
            id: id,
            style: style,
            layerPosition: nil,
            displayLinkCoordinator: displayLinkCoordinator,
            clusterOptions: clusterOptions,
            imagesManager: imagesManager,
            <%_ if (type === circle || type === symbol) { _%>
            offsetPointCalculator: offsetPointCalculator
            <%_ } else if ( type === line ) { _%>
            offsetLineStringCalculator: offsetLineStringCalculator
            <%_ } else if ( type === fill ) { _%>
            offsetPolygonCalculator: offsetPolygonCalculator
            <%_ } _%>
        )
        pointAnnotationManager.annotations = annotations

        // then
        let circleLayerInvocations = style.addPersistentLayerStub.invocations.filter { circleLayer in
            return circleLayer.parameters.layer.id == "mapbox-iOS-cluster-circle-layer-manager-" + id
        }
        let circleLayer = circleLayerInvocations[0].parameters.layer as! CircleLayer

        XCTAssertEqual(clusterOptions.circleRadius, testCircleRadius)
        XCTAssertEqual(circleLayer.circleRadius, testCircleRadius)
        XCTAssertEqual(clusterOptions.circleColor, testCircleColor)
        XCTAssertEqual(circleLayer.circleColor, testCircleColor)
        XCTAssertEqual(circleLayer.filter, Exp(.has) { "point_count" })
        XCTAssertEqual(circleLayer.id, "mapbox-iOS-cluster-circle-layer-manager-" + id)
        XCTAssertEqual(style.addSourceStub.invocations.count, 1)
    }

    func testTextLayer() {
        style.addSourceStub.reset()
        style.addPersistentLayerStub.reset()
        // given
        let testTextColor = Value<StyleColor>.testConstantValue()
        let testTextSize = Value<Double>.testConstantValue()
        let testTextField = Value<String>.testConstantValue()
        let clusterOptions = ClusterOptions(textColor: testTextColor,
                                            textSize: testTextSize,
                                            textField: testTextField)
        var annotations = [PointAnnotation]()
        for _ in 0...500 {
            let annotation = PointAnnotation(coordinate: .random(), isSelected: false, isDraggable: false)
            annotations.append(annotation)
        }

        // when
        let pointAnnotationManager = PointAnnotationManager(
            id: id,
            style: style,
            layerPosition: nil,
            displayLinkCoordinator: displayLinkCoordinator,
            clusterOptions: clusterOptions,
            imagesManager: imagesManager,
            <%_ if (type === circle || type === symbol) { _%>
            offsetPointCalculator: offsetPointCalculator
            <%_ } else if ( type === line ) { _%>
            offsetLineStringCalculator: offsetLineStringCalculator
            <%_ } else if ( type === fill ) { _%>
            offsetPolygonCalculator: offsetPolygonCalculator
            <%_ } _%>
        )
        pointAnnotationManager.annotations = annotations

        // then
        let textLayerInvocations = style.addPersistentLayerStub.invocations.filter { symbolLayer in
            return symbolLayer.parameters.layer.id == "mapbox-iOS-cluster-text-layer-manager-" + id
        }
        let textLayer = textLayerInvocations[0].parameters.layer as! SymbolLayer

        XCTAssertEqual(textLayer.textColor, testTextColor)
        XCTAssertEqual(textLayer.textSize, testTextSize)
        XCTAssertEqual(textLayer.textField, testTextField)
        XCTAssertEqual(style.addSourceStub.invocations.count, 1)
    }

    func testSymbolLayers() {
        style.addSourceStub.reset()
        style.addPersistentLayerStub.reset()
        // given
        let clusterOptions = ClusterOptions()
        var annotations = [PointAnnotation]()
        for _ in 0...500 {
            let annotation = PointAnnotation(coordinate: .random(), isSelected: false, isDraggable: false)
            annotations.append(annotation)
        }

        // when
        let pointAnnotationManager = PointAnnotationManager(
            id: id,
            style: style,
            layerPosition: nil,
            displayLinkCoordinator: displayLinkCoordinator,
            clusterOptions: clusterOptions,
            imagesManager: imagesManager,
            <%_ if (type === circle || type === symbol) { _%>
            offsetPointCalculator: offsetPointCalculator
            <%_ } else if ( type === line ) { _%>
            offsetLineStringCalculator: offsetLineStringCalculator
            <%_ } else if ( type === fill ) { _%>
            offsetPolygonCalculator: offsetPolygonCalculator
            <%_ } _%>
        )
        pointAnnotationManager.annotations = annotations

        // then
        let symbolLayerInvocations = style.addPersistentLayerStub.invocations.filter { symbolLayer in
            return symbolLayer.parameters.layer.id == id
        }
        let symbolLayer = symbolLayerInvocations[0].parameters.layer as! SymbolLayer

        XCTAssertTrue(symbolLayer.iconAllowOverlap == .constant(true))
        XCTAssertTrue(symbolLayer.textAllowOverlap == .constant(true))
        XCTAssertTrue(symbolLayer.iconIgnorePlacement == .constant(true))
        XCTAssertTrue(symbolLayer.textIgnorePlacement == .constant(true))
        XCTAssertEqual(symbolLayer.source, id)
        XCTAssertEqual(style.addSourceStub.invocations.count, 1)
    }

    func testChangeAnnotations() {
        style.addSourceStub.reset()
        style.addPersistentLayerStub.reset()
        // given
        let clusterOptions = ClusterOptions()
        var annotations = [PointAnnotation]()
        for _ in 0...500 {
            let annotation = PointAnnotation(coordinate: .random(), isSelected: false, isDraggable: false)
            annotations.append(annotation)
        }
        var newAnnotations = [PointAnnotation]()
        for _ in 0...100 {
            let annotation = PointAnnotation(coordinate: .random(), isSelected: false, isDraggable: false)
            newAnnotations.append(annotation)
        }

        // when
        let pointAnnotationManager = PointAnnotationManager(
            id: id,
            style: style,
            layerPosition: nil,
            displayLinkCoordinator: displayLinkCoordinator,
            clusterOptions: clusterOptions,
            imagesManager: imagesManager,
            <%_ if (type === circle || type === symbol) { _%>
            offsetPointCalculator: offsetPointCalculator
            <%_ } else if ( type === line ) { _%>
            offsetLineStringCalculator: offsetLineStringCalculator
            <%_ } else if ( type === fill ) { _%>
            offsetPolygonCalculator: offsetPolygonCalculator
            <%_ } _%>
        )
        pointAnnotationManager.annotations = annotations
        pointAnnotationManager.syncSourceAndLayerIfNeeded()
        var sourceGeoJSON = style.updateGeoJSONSourceStub.invocations.last?.parameters.geojson
        switch sourceGeoJSON {
        case .featureCollection(let data):
            XCTAssertEqual(data.features.count, 501)
        default:
            XCTFail("GeoJSON did not update correctly")
        }

        // then
        pointAnnotationManager.annotations = newAnnotations
        pointAnnotationManager.syncSourceAndLayerIfNeeded()
        sourceGeoJSON = style.updateGeoJSONSourceStub.invocations.last?.parameters.geojson
        switch sourceGeoJSON {
        case .featureCollection(let data):
            XCTAssertEqual(data.features.count, 101)
        default:
            XCTFail("GeoJSON did not update correctly")
        }
        XCTAssertEqual(style.addSourceStub.invocations.count, 1)
    }

    func testDestroyAnnotationManager() {
        // given
        let clusterOptions = ClusterOptions()

        // when
        let pointAnnotationManager = PointAnnotationManager(
            id: id,
            style: style,
            layerPosition: nil,
            displayLinkCoordinator: displayLinkCoordinator,
            clusterOptions: clusterOptions,
            imagesManager: imagesManager,
            <%_ if (type === circle || type === symbol) { _%>
            offsetPointCalculator: offsetPointCalculator
            <%_ } else if ( type === line ) { _%>
            offsetLineStringCalculator: offsetLineStringCalculator
            <%_ } else if ( type === fill ) { _%>
            offsetPolygonCalculator: offsetPolygonCalculator
            <%_ } _%>
        )
        pointAnnotationManager.annotations = annotations
        pointAnnotationManager.destroy()

        let removeLayerInvocations = style.removeLayerStub.invocations

        // then
        XCTAssertEqual(removeLayerInvocations.map(\.parameters), [
            "mapbox-iOS-cluster-circle-layer-manager-" + id,
            "mapbox-iOS-cluster-text-layer-manager-" + id,
            id + "_drag-layer",
            id,
        ])
    }
    <%_ } _%>

    func testGetAnnotations() {
        let annotations = Array.random(withLength: 10) {
            <%_ if ( type === symbol) { _%>
            PointAnnotation(coordinate: .random(), isSelected: false, isDraggable: true)
            <%_ } else if ( type === circle ) { _%>
            CircleAnnotation(centerCoordinate: .random(), isSelected: false, isDraggable: true)
            <%_ } else if ( type === line ) { _%>
            PolylineAnnotation(lineCoordinates: [ CLLocationCoordinate2D(latitude: 0, longitude: 0), CLLocationCoordinate2D(latitude: 10, longitude: 10)], isSelected: false, isDraggable: true)
            <%_ } else if ( type === fill ) { _%>
            PolygonAnnotation(
                polygon: .init(outerRing: Ring(coordinates: .random(withLength: 5, generator: LocationCoordinate2D.random))),
                isSelected: false,
                isDraggable: true)
            <%_ } _%>
        }
        manager.annotations = annotations

        // Dragged annotation will be added to internal list of dragged annotations.
        let annotationToDrag = annotations.randomElement()!
        manager.handleDragBegin(with: [annotationToDrag.id])
        XCTAssertTrue(manager.annotations.contains(where: { $0.id == annotationToDrag.id }))
    }

    func testHandleDragBeginIsDraggableFalse() throws {
        <%_ if ( type === symbol) { _%>
        manager.annotations = [
            PointAnnotation(id: "point1", coordinate: .random(), isSelected: false, isDraggable: false)
        ]
        <%_ } else if ( type === circle ) { _%>
        manager.annotations = [
            CircleAnnotation(id: "circle1", centerCoordinate: .random(), isSelected: false, isDraggable: false)
        ]
        <%_ } else if ( type === line ) { _%>
        manager.annotations = [
            PolylineAnnotation(id: "line1", lineCoordinates: [ CLLocationCoordinate2D(latitude: 0, longitude: 0), CLLocationCoordinate2D(latitude: 10, longitude: 10)], isSelected: false, isDraggable: false)
        ]
        <%_ } else if ( type === fill ) { _%>
        manager.annotations = [
            PolygonAnnotation(id: "polygon1", polygon: .init([[
                CLLocationCoordinate2DMake(24.51713945052515, -89.857177734375),
                CLLocationCoordinate2DMake(24.51713945052515, -87.967529296875),
                CLLocationCoordinate2DMake(26.244156283890756, -87.967529296875),
                CLLocationCoordinate2DMake(26.244156283890756, -89.857177734375),
                CLLocationCoordinate2DMake(24.51713945052515, -89.857177734375)
            ]]), isSelected: false, isDraggable: false)
        ]
        <%_ } _%>

        style.addSourceStub.reset()
        style.addPersistentLayerWithPropertiesStub.reset()

        <%_ if ( type === circle ) { _%>
        manager.handleDragBegin(with: ["circle1"])
        <%_ } else if ( type === symbol ) { _%>
        manager.handleDragBegin(with: ["point1"])
        <%_ } else if ( type === line ) { _%>
        manager.handleDragBegin(with: ["line1"])
        <%_ } else if ( type === fill ) { _%>
        manager.handleDragBegin(with: ["polygon1"])
        <%_ } _%>

        XCTAssertEqual(style.addSourceStub.invocations.count, 0)
        XCTAssertEqual(style.addPersistentLayerWithPropertiesStub.invocations.count, 0)
        XCTAssertEqual(style.updateGeoJSONSourceStub.invocations.count, 0)
    }

    func testHandleDragBeginNoFeatureId() {
        style.addSourceStub.reset()
        style.addPersistentLayerWithPropertiesStub.reset()

        manager.handleDragBegin(with: [])

        XCTAssertTrue(style.addSourceStub.invocations.isEmpty)
        XCTAssertTrue(style.addLayerStub.invocations.isEmpty)
        XCTAssertTrue(style.updateGeoJSONSourceStub.invocations.isEmpty)
    }

    func testHandleDragBeginInvalidFeatureId() {
        style.addSourceStub.reset()
        style.addPersistentLayerWithPropertiesStub.reset()

        manager.handleDragBegin(with: ["not-a-feature"])

        XCTAssertTrue(style.addSourceStub.invocations.isEmpty)
        XCTAssertTrue(style.addPersistentLayerWithPropertiesStub.invocations.isEmpty)
        XCTAssertTrue(style.updateGeoJSONSourceStub.invocations.isEmpty)
    }

    func testHandleDragBegin() throws {
        <%_ if ( type === symbol) { _%>
        manager.annotations = [
            PointAnnotation(id: "point1", coordinate: .random(), isSelected: false, isDraggable: true)
        ]
        <%_ } else if ( type === circle ) { _%>
        manager.annotations = [
            CircleAnnotation(id: "circle1", centerCoordinate: .random(), isSelected: false, isDraggable: true)
        ]
        <%_ } else if ( type === line ) { _%>
        manager.annotations = [
            PolylineAnnotation(id: "line1", lineCoordinates: [ CLLocationCoordinate2D(latitude: 0, longitude: 0), CLLocationCoordinate2D(latitude: 10, longitude: 10)], isSelected: false, isDraggable: true)
        ]
        <%_ } else if ( type === fill ) { _%>
        manager.annotations = [
            PolygonAnnotation(id: "polygon1", polygon: .init([[
                CLLocationCoordinate2DMake(24.51713945052515, -89.857177734375),
                CLLocationCoordinate2DMake(24.51713945052515, -87.967529296875),
                CLLocationCoordinate2DMake(26.244156283890756, -87.967529296875),
                CLLocationCoordinate2DMake(26.244156283890756, -89.857177734375),
                CLLocationCoordinate2DMake(24.51713945052515, -89.857177734375)
            ]]), isSelected: false, isDraggable: true)
        ]
        <%_ } _%>

        style.addSourceStub.reset()
        style.addPersistentLayerWithPropertiesStub.reset()

        <%_ if ( type === circle ) { _%>
        manager.handleDragBegin(with: ["circle1"])
        <%_ } else if ( type === symbol ) { _%>
        manager.handleDragBegin(with: ["point1"])
        <%_ } else if ( type === line ) { _%>
        manager.handleDragBegin(with: ["line1"])
        <%_ } else if ( type === fill ) { _%>
        manager.handleDragBegin(with: ["polygon1"])
        <%_ } _%>

        let addSourceParameters = try XCTUnwrap(style.addSourceStub.invocations.last).parameters
        let addLayerParameters = try XCTUnwrap(style.addPersistentLayerWithPropertiesStub.invocations.last).parameters
        let updateSourceParameters = try XCTUnwrap(style.updateGeoJSONSourceStub.invocations.last).parameters

        XCTAssertEqual(addLayerParameters.properties["source"] as? String, addSourceParameters.source.id)
        XCTAssertNotEqual(addLayerParameters.properties["id"] as? String, manager.layerId)

        XCTAssertTrue(updateSourceParameters.id == addSourceParameters.source.id)
    }

    func testHandleDragChanged() throws {
        mapboxMap.pointStub.defaultReturnValue = CGPoint(x: 0, y: 0)
        mapboxMap.coordinateForPointStub.defaultReturnValue = .random()
        mapboxMap.cameraState.zoom = 1

        <%_ if ( type === symbol) { _%>
        let annotation = PointAnnotation(id: "point1", coordinate: .init(latitude: 0, longitude: 0), isSelected: false, isDraggable: true)
        <%_ } else if ( type === circle ) { _%>
        let annotation = CircleAnnotation(id: "circle1", centerCoordinate: .init(latitude: 0, longitude: 0), isSelected: false, isDraggable: true)
        <%_ } else if ( type === line ) { _%>
        let annotation = PolylineAnnotation(id: "line1", lineCoordinates: [ CLLocationCoordinate2D(latitude: 0, longitude: 0), CLLocationCoordinate2D(latitude: 10, longitude: 10)], isSelected: false, isDraggable: true)
        <%_ } else if ( type === fill ) { _%>
        let annotation = PolygonAnnotation(
            id: "polygon1",
            polygon: .init([[
                CLLocationCoordinate2DMake(24.51713945052515, -89.857177734375),
                CLLocationCoordinate2DMake(24.51713945052515, -87.967529296875),
                CLLocationCoordinate2DMake(26.244156283890756, -87.967529296875),
                CLLocationCoordinate2DMake(26.244156283890756, -89.857177734375),
                CLLocationCoordinate2DMake(24.51713945052515, -89.857177734375)
            ]]),
            isSelected: false,
            isDraggable: true)
        <%_ } _%>
        manager.annotations = [annotation]

        manager.handleDragChanged(with: .random())
        XCTAssertTrue(style.updateGeoJSONSourceStub.invocations.isEmpty)

        <%_ if ( type === circle ) { _%>
        manager.handleDragBegin(with: ["circle1"])
        <%_ } else if ( type === symbol ) { _%>
        manager.handleDragBegin(with: ["point1"])
        <%_ } else if ( type === line ) { _%>
        manager.handleDragBegin(with: ["line1"])
        <%_ } else if ( type === fill ) { _%>
        manager.handleDragBegin(with: ["polygon1"])
        <%_ } _%>
        let addSourceParameters = try XCTUnwrap(style.addSourceStub.invocations.last).parameters

        manager.handleDragChanged(with: .random())
        let updateSourceParameters = try XCTUnwrap(style.updateGeoJSONSourceStub.invocations.last).parameters
        XCTAssertTrue(updateSourceParameters.id == addSourceParameters.source.id)
        if case .featureCollection(let collection) = updateSourceParameters.geojson {
            XCTAssertTrue(collection.features.contains(where: { $0.identifier?.rawValue as? String == annotation.id }))
        } else {
            XCTFail("GeoJSONObject should be a feature collection")
        }
    }
}

<%_ if (isPointAnnotationManager) { _%>
private extension PointAnnotation {
    init(image: Image) {
        self.init(coordinate: .random())
        self.image = image
    }
}
<%_ } _%>
// End of generated file
