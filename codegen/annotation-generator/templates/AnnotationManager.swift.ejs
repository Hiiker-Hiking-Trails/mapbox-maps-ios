<%_
  const type = locals.type
  const originalType = locals.orignalType
  const properties = locals.properties
  const isPointAnnotationManager = type === "point" // check for behaviors/properties which only apply to PointAnnotationManagers
  const symbol = "point"
  const circle = "circle"
  const fill = "polygon"
  const line = "polyline"
  const specialSymbolLayerProperties = ["icon-allow-overlap", "text-allow-overlap", "icon-ignore-placement", "text-ignore-placement"]
_%>
// This file is generated.
import Foundation
import os
@_implementationOnly import MapboxCommon_Private

/// An instance of `<%- camelize(type) %>AnnotationManager` is responsible for a collection of `<%- camelize(type) %>Annotation`s.
public class <%- camelize(type) %>AnnotationManager: AnnotationManagerInternal {

    // MARK: - Annotations

    /// The collection of ``<%- camelize(type) %>Annotation`` being managed.
    public var annotations: [<%- camelize(type) %>Annotation] {
        get {
            let allAnnotations = mainAnnotations.merging(draggedAnnotations) { $1 }
            return Array(allAnnotations.values)
        }
        set {
            mainAnnotations = newValue.reduce(into: [:]) { partialResult, annotation in
                partialResult[annotation.id] = annotation
            }

            draggedAnnotations = [:]
            annotationBeingDragged = nil
            needsSyncDragSource = true
        }
    }

    /// The collection of ``<%- camelize(type) %>Annotation`` that has been dragged.
    private var draggedAnnotations: [String: <%- camelize(type) %>Annotation] = [:]
    /// The collection of ``<%- camelize(type) %>Annotation`` in the main source.
    private var mainAnnotations: [String: <%- camelize(type) %>Annotation] = [:] {
        didSet {
            needsSyncSourceAndLayer = true
        }
    }

    private var needsSyncSourceAndLayer = false
    private var needsSyncDragSource = false
    <%_ if (isPointAnnotationManager) { _%>
    /// List of images used by this ``PointAnnotationManager``.
    private(set) internal var allImages = Set<String>()
    private let imagesManager: AnnotationImagesManagerProtocol
    private var clusterOptions: ClusterOptions?
    <%_ } _%>

    // MARK: - Interaction

    /// Set this delegate in order to be called back if a tap occurs on an annotation being managed by this manager.
    /// - NOTE: This annotation manager listens to tap events via the `GestureManager.singleTapGestureRecognizer`.
    public weak var delegate: AnnotationInteractionDelegate?

    // MARK: - AnnotationManager protocol conformance

    public let sourceId: String

    public let layerId: String

    public let id: String

    // MARK: - Setup / Lifecycle

    /// Dependency required to add sources/layers to the map
    private let style: StyleProtocol

    /// Storage for common layer properties
    private var layerProperties: [String: Any] = [:] {
        didSet {
            needsSyncSourceAndLayer = true
        }
    }

    /// The keys of the style properties that were set during the previous sync.
    /// Used to identify which styles need to be restored to their default values in
    /// the subsequent sync.
    private var previouslySetLayerPropertyKeys: Set<String> = []

    private let displayLinkParticipant = DelegatingDisplayLinkParticipant()

    private weak var displayLinkCoordinator: DisplayLinkCoordinator?

    <%_ if (type === circle || type === symbol) { _%>
    private let offsetPointCalculator: OffsetPointCalculator
    <%_ } else if ( type === line ) { _%>
    private let offsetLineStringCalculator: OffsetLineStringCalculator
    <%_ } else if ( type === fill ) { _%>
    private let offsetPolygonCalculator: OffsetPolygonCalculator
    <%_ } _%>

    <%_ if (type === circle) { _%>
    private var annotationBeingDragged: CircleAnnotation?
    <%_ } else if ( type === fill ) { _%>
    private var annotationBeingDragged: PolygonAnnotation?
    <%_ } else if ( type === symbol ) { _%>
    private var annotationBeingDragged: PointAnnotation?
    <%_ } else if ( type === line ) { _%>
    private var annotationBeingDragged: PolylineAnnotation?
    <%_ } _%>

    private var isDestroyed = false
    private let dragLayerId: String
    private let dragSourceId: String

    var allLayerIds: [String] { [layerId, dragLayerId] }

    internal init(id: String,
                  style: StyleProtocol,
                  layerPosition: LayerPosition?,
                  displayLinkCoordinator: DisplayLinkCoordinator?<%_ if (isPointAnnotationManager) { _%>,
                  clusterOptions: ClusterOptions? = nil,
                  imagesManager: AnnotationImagesManagerProtocol<%_ } _%>,
                  <%_ if (type === circle || type === symbol) { _%>
                  offsetPointCalculator: OffsetPointCalculator) {
                  <%_ } else if ( type === line ) { _%>
                  offsetLineStringCalculator: OffsetLineStringCalculator) {
                  <%_ } else if ( type === fill ) { _%>
                  offsetPolygonCalculator: OffsetPolygonCalculator) {
                  <%_ } _%>
        self.id = id
        self.sourceId = id
        self.layerId = id
        self.style = style
        <%_ if (isPointAnnotationManager) { _%>
        self.clusterOptions = clusterOptions
        self.imagesManager = imagesManager
        <%_ } _%>
        self.displayLinkCoordinator = displayLinkCoordinator
        <%_ if (type === circle || type === symbol) { _%>
        self.offsetPointCalculator = offsetPointCalculator
        <%_ } else if ( type === line ) { _%>
        self.offsetLineStringCalculator = offsetLineStringCalculator
        <%_ } else if ( type === fill ) { _%>
        self.offsetPolygonCalculator = offsetPolygonCalculator
        <%_ } _%>
        self.dragLayerId = id + "_drag-layer"
        self.dragSourceId = id + "_drag-source"
        <%_ if (isPointAnnotationManager) { %>
        imagesManager.register(imagesConsumer: self)
        <%_ } %>
        do {
            // Add the source with empty `data` property
            var source = GeoJSONSource()
            source.data = .empty
            <%_ if (isPointAnnotationManager) { _%>

            // Set cluster options and create clusters if clustering is enabled
            if let clusterOptions = clusterOptions {
                source.cluster = true
                source.clusterRadius = clusterOptions.clusterRadius
                source.clusterProperties = clusterOptions.clusterProperties
                source.clusterMaxZoom = clusterOptions.clusterMaxZoom
            }

            <%_ } _%>
            try style.addSource(source, id: sourceId)
            <%_ if (isPointAnnotationManager) { _%>

            if let clusterOptions = clusterOptions {
                createClusterLayers(clusterOptions: clusterOptions)
            }
            <%_ } _%>

            // Add the correct backing layer for this annotation type
            var layer = <%- camelize(originalType) %>Layer(id: layerId)
            layer.source = sourceId
            <%_ if (isPointAnnotationManager) { _%>

            // Show all icons and texts by default in point annotations.
            layer.iconAllowOverlap = .constant(true)
            layer.textAllowOverlap = .constant(true)
            layer.iconIgnorePlacement = .constant(true)
            layer.textIgnorePlacement = .constant(true)
            <%_ } _%>
            try style.addPersistentLayer(layer, layerPosition: layerPosition)
        } catch {
            Log.error(
                forMessage: "Failed to create source / layer in <%- camelize(type) %>AnnotationManager. Error: \(error)",
                category: "Annotations")
        }

        self.displayLinkParticipant.delegate = self

        assert(displayLinkCoordinator != nil, "DisplayLinkCoordinator must be present")
        displayLinkCoordinator?.add(displayLinkParticipant)
    }

    <%_ if (isPointAnnotationManager) { _%>
    private func createClusterLayers(clusterOptions: ClusterOptions) {
        let clusterLevelLayer = createClusterLevelLayer(clusterOptions: clusterOptions)
        let clusterTextLayer = createClusterTextLayer(clusterOptions: clusterOptions)
        do {
            try addClusterLayer(clusterLayer: clusterLevelLayer)
            try addClusterLayer(clusterLayer: clusterTextLayer)
        } catch {
            Log.error(
                forMessage: "Failed to add cluster layer in PointAnnotationManager. Error: \(error)",
                category: "Annotations")
        }
    }

    private func addClusterLayer(clusterLayer: Layer) throws {
        guard style.layerExists(withId: clusterLayer.id) else {
            try style.addPersistentLayer(clusterLayer, layerPosition: .default)
            return
        }
    }

    private func createClusterLevelLayer(clusterOptions: ClusterOptions) -> CircleLayer {
        let layedID = "mapbox-iOS-cluster-circle-layer-manager-" + id
        var circleLayer = CircleLayer(id: layedID)
        circleLayer.source = sourceId
        circleLayer.circleColor = clusterOptions.circleColor
        circleLayer.circleRadius = clusterOptions.circleRadius
        circleLayer.filter = Exp(.has) { "point_count" }
        return circleLayer
    }

    private func createClusterTextLayer(clusterOptions: ClusterOptions) -> SymbolLayer {
        let layerID = "mapbox-iOS-cluster-text-layer-manager-" + id
        var symbolLayer = SymbolLayer(id: layerID)
        symbolLayer.source = sourceId
        symbolLayer.textField = clusterOptions.textField
        symbolLayer.textSize = clusterOptions.textSize
        symbolLayer.textColor = clusterOptions.textColor
        return symbolLayer
    }

    private func destroyClusterLayers() {
        do {
            try style.removeLayer(withId: "mapbox-iOS-cluster-circle-layer-manager-" + id)
            try style.removeLayer(withId: "mapbox-iOS-cluster-text-layer-manager-" + id)
        } catch {
            Log.error(
                forMessage: "Failed to remove cluster layer in PointAnnotationManager. Error: \(error)",
                category: "Annotations")
        }
    }

    <%_ } _%>
    internal func destroy() {
        guard !isDestroyed else {
            return
        }
        isDestroyed = true
        <%_ if (isPointAnnotationManager) { _%>

        if clusterOptions != nil {
            destroyClusterLayers()
        }
        <%_ } _%>

        removeDragSourceAndLayer()

        do {
            try style.removeLayer(withId: layerId)
        } catch {
            Log.warning(
                forMessage: "Failed to remove layer for <%- camelize(type) %>AnnotationManager with id \(id) due to error: \(error)",
                category: "Annotations")
        }
        do {
            try style.removeSource(withId: sourceId)
        } catch {
            Log.warning(
                forMessage: "Failed to remove source for <%- camelize(type) %>AnnotationManager with id \(id) due to error: \(error)",
                category: "Annotations")
        }
        <%_ if (isPointAnnotationManager) { _%>
        removeAllImages()
        <%_ } _%>
        displayLinkCoordinator?.remove(displayLinkParticipant)
    }

    // MARK: - Sync annotations to map

    /// Synchronizes the backing source and layer with the current `annotations`
    /// and common layer properties. This method is called automatically with
    /// each display link, but it may also be called manually in situations
    /// where the backing source and layer need to be updated earlier.
    public func syncSourceAndLayerIfNeeded() {
        guard needsSyncSourceAndLayer, !isDestroyed else {
            return
        }
        needsSyncSourceAndLayer = false
        let allAnnotations = annotations

        <%_ if (isPointAnnotationManager) { _%>
        let newImages = Set(allAnnotations.compactMap(\.image))
        let newImageNames = Set(newImages.map(\.name))
        let unusedImages = allImages.subtracting(newImageNames)

        addImages(newImages)
        allImages = newImageNames

        removeImages(unusedImages)

        <%_ } _%>
        // Construct the properties dictionary from the annotations
        let dataDrivenLayerPropertyKeys = Set(allAnnotations.flatMap(\.layerProperties.keys))
        let dataDrivenProperties = Dictionary(
            uniqueKeysWithValues: dataDrivenLayerPropertyKeys
                .map { (key) -> (String, Any) in
                    (key, ["get", key, ["get", "layerProperties"]] as [Any])
                })

        // Merge the common layer properties
        let newLayerProperties = dataDrivenProperties.merging(layerProperties, uniquingKeysWith: { $1 })

        // Construct the properties dictionary to reset any properties that are no longer used
        let unusedPropertyKeys = previouslySetLayerPropertyKeys.subtracting(newLayerProperties.keys)
        let unusedProperties = Dictionary(uniqueKeysWithValues: unusedPropertyKeys.map { (key) -> (String, Any) in
            (key, Style.layerPropertyDefaultValue(for: .<%- originalType %>, property: key).value)
        })

        // Store the new set of property keys
        previouslySetLayerPropertyKeys = Set(newLayerProperties.keys)

        // Merge the new and unused properties
        let allLayerProperties = newLayerProperties.merging(unusedProperties, uniquingKeysWith: { $1 })

        // make a single call into MapboxCoreMaps to set layer properties
        do {
            try style.setLayerProperties(for: layerId, properties: allLayerProperties)
        } catch {
            Log.error(
                forMessage: "Could not set layer properties in <%- camelize(type) -%>AnnotationManager due to error \(error)",
                category: "Annotations")
        }

        // build and update the source data
        do {
            let featureCollection = FeatureCollection(features: mainAnnotations.values.map(\.feature))
            try style.updateGeoJSONSource(withId: sourceId, geoJSON: .featureCollection(featureCollection))
        } catch {
            Log.error(
                forMessage: "Could not update annotations in <%- camelize(type) %>AnnotationManager due to error: \(error)",
                category: "Annotations")
        }
    }

    private func syncDragSourceIfNeeded() {
        guard !isDestroyed, needsSyncDragSource else { return }

        needsSyncDragSource = false
        if style.sourceExists(withId: dragSourceId) {
            updateDragSource()
        }
    }

    // MARK: - Common layer properties
    <%_ for (const property of properties) { _%>
    <%_ if (!supportsPropertyFunction(property) && !shouldSkipAnnotationProperty(type, property)) { _%>

    /// <%- markdownFriendlyDoc(property) %>
    public var <%- camelizeWithLeadingLowercase(property.name) %>: <%- propertySwiftType(property) %>? {
        get {
            return <%- propertyJSONValueToSwiftTypeConvertor(property) %>
        }
        set {
            layerProperties["<%- property.name %>"] = <%- propertySwiftTypeToJSONValueConvertor(property) %>
        }
    }
    <%_ } _%>
    <%_ } _%>

    <%_ if (isPointAnnotationManager) { _%>
    /// Scales the icon to fit around the associated text.
    @available(*, deprecated, message: "icon-text-fit property is now data driven, use `PointAnnotation.iconTextFit` instead.")
    public var iconTextFit: IconTextFit? {
        get {
            return layerProperties["icon-text-fit"].flatMap { $0 as? String }.flatMap(IconTextFit.init(rawValue:))
        }
        set {
            layerProperties["icon-text-fit"] = newValue?.rawValue
        }
    }

    /// Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left.
    @available(*, deprecated, message: "icon-text-fit-padding property is now data driven, use `PointAnnotation.iconTextFitPadding` instead.")
    public var iconTextFitPadding: [Double]? {
        get {
            return layerProperties["icon-text-fit-padding"] as? [Double]
        }
        set {
            layerProperties["icon-text-fit-padding"] = newValue
        }
    }
    
    <%_ } _%>   
    // MARK: - User interaction handling

    /// Returns the first annotation matching the set of given `featureIdentifiers`.
    private func findAnnotation(from featureIdentifiers: [String], where predicate: (<%- camelize(type) %>Annotation) -> Bool) -> <%- camelize(type) %>Annotation? {
        for featureIdentifier in featureIdentifiers {
            if let annotation = mainAnnotations[featureIdentifier] ?? draggedAnnotations[featureIdentifier], predicate(annotation) {
                return annotation
            }
        }
        return nil
    }

    internal func handleQueriedFeatureIds(_ queriedFeatureIds: [String]) {
        guard annotations.map(\.id).contains(where: queriedFeatureIds.contains(_:)) else {
            return
        }

        <%_ if ( type === circle ) { _%>
        var tappedAnnotations: [CircleAnnotation] = []
        var annotations: [CircleAnnotation] = []
        <%_ } else if ( type === symbol ) { _%>
        var tappedAnnotations: [PointAnnotation] = []
        var annotations: [PointAnnotation] = []
        <%_ } else if ( type === line ) { _%>
        var tappedAnnotations: [PolylineAnnotation] = []
        var annotations: [PolylineAnnotation] = []
        <%_ } else if ( type === fill ) { _%>
        var tappedAnnotations: [PolygonAnnotation] = []
        var annotations: [PolygonAnnotation] = []
        <%_ } _%>

        for var annotation in self.annotations {
            if queriedFeatureIds.contains(annotation.id) {
                annotation.isSelected.toggle()
                tappedAnnotations.append(annotation)
            }
            annotations.append(annotation)
        }

        self.annotations = annotations

        delegate?.annotationManager(
            self,
            didDetectTappedAnnotations: tappedAnnotations)
    }

    private func updateDragSource() {
        do {
            if let annotationBeingDragged = annotationBeingDragged {
                draggedAnnotations[annotationBeingDragged.id] = annotationBeingDragged
            }
            try style.updateGeoJSONSource(withId: dragSourceId, geoJSON: .featureCollection(.init(features: draggedAnnotations.values.map(\.feature))))
        } catch {
            Log.error(forMessage: "Failed to update drag source. Error: \(error)")
        }
    }

    private func updateDragLayer() {
        do {
            // copy the existing layer as the drag layer
            var properties = try style.layerProperties(for: layerId)
            properties[SymbolLayer.RootCodingKeys.id.rawValue] = dragLayerId
            properties[SymbolLayer.RootCodingKeys.source.rawValue] = dragSourceId

            if style.layerExists(withId: dragLayerId) {
                try style.setLayerProperties(for: dragLayerId, properties: properties)
            } else {
                try style.addPersistentLayer(with: properties, layerPosition: .above(layerId))
            }
        } catch {
            Log.error(forMessage: "Failed to update the layer to style. Error: \(error)")
        }
    }

    private func removeDragSourceAndLayer() {
        do {
            try style.removeLayer(withId: dragLayerId)
            try style.removeSource(withId: dragSourceId)
        } catch {
            Log.error(forMessage: "Failed to remove drag layer. Error: \(error)")
        }
    }

    internal func handleDragBegin(with featureIdentifiers: [String]) {
        guard let annotation = findAnnotation(from: featureIdentifiers, where: { $0.isDraggable }) else { return }

        do {
            if !style.sourceExists(withId: dragSourceId) {
                var dragSource = GeoJSONSource()
                dragSource.data = .empty
                try style.addSource(dragSource, id: dragSourceId)
            }

            annotationBeingDragged = annotation
            mainAnnotations[annotation.id] = nil

            updateDragSource()
            updateDragLayer()
        } catch {
            Log.error(forMessage: "Failed to create the drag source to style. Error: \(error)")
        }
    }

    internal func handleDragChanged(with translation: CGPoint) {
        <%_ if ( type === symbol || type === circle ) { _%>
        guard let annotationBeingDragged = annotationBeingDragged,
              let offsetPoint = offsetPointCalculator.geometry(for: translation, from: annotationBeingDragged.point) else {
            return
        }

        self.annotationBeingDragged?.point = offsetPoint
        <%_ } else if ( type === line ) { _%>
        guard let annotationBeingDragged = annotationBeingDragged,
        let offsetPoint = offsetLineStringCalculator.geometry(for: translation, from: annotationBeingDragged.lineString) else {
            return
        }

        self.annotationBeingDragged?.lineString = offsetPoint
        <%_ } else if ( type === fill ) { _%>
        guard let annotationBeingDragged = annotationBeingDragged,
        let offsetPoint = offsetPolygonCalculator.geometry(for: translation, from: annotationBeingDragged.polygon) else {
            return
        }

        self.annotationBeingDragged?.polygon = offsetPoint
        <%_ } _%>
        updateDragSource()
    }

    internal func handleDragEnded() {
        annotationBeingDragged = nil
    }
}

extension <%- camelize(type) %>AnnotationManager: DelegatingDisplayLinkParticipantDelegate {
    func participate(for participant: DelegatingDisplayLinkParticipant) {
        OSLog.platform.withIntervalSignpost(SignpostName.mapViewDisplayLink,
                                            "Participant: <%- camelize(type) %>AnnotationManager") {
            syncSourceAndLayerIfNeeded()
            syncDragSourceIfNeeded()
        }
    }
}

<%_ if (isPointAnnotationManager) { _%>
private extension <%- camelize(type) %>AnnotationManager {

    func addImages(_ images: Set<PointAnnotation.Image>) {
        for image in images {
            imagesManager.addImage(image.image, id: image.name, sdf: false, contentInsets: .zero)
        }
    }

    func removeImages(_ names: Set<String>) {
        for imageName in names {
            imagesManager.removeImage(imageName)
        }
    }

    func removeAllImages() {
        let imagesToRemove = allImages
        allImages.removeAll()
        removeImages(imagesToRemove)
    }
}
<%_ } _%>
// End of generated file.
