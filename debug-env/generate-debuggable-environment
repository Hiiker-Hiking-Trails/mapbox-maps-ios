#!/usr/bin/env python3

import os
import argparse
import json
import re

SNAPSHOT_RE = r'\d+\.\d+\.\d+-SNAPSHOT\.[^.]+\.([\w\d]+)'

def print_phase(phase: str):
    print('\033[93m' + f"{phase}" + '\033[0m')


def get_snapshot_commit(version):
    match = re.search(SNAPSHOT_RE, version)
    if match:
        return match.group(1)
    return None


def resolve_version(version, tag_prefix):
    shapshot_commit = get_snapshot_commit(version)
    return shapshot_commit if shapshot_commit else tag_prefix + version


def main():
    parser = argparse.ArgumentParser(description='Generate project to build Maps SDK dependencies from sources.')
    parser.add_argument('--gl-native-commit', default=None,
                        type=str, help='commit to use for GL Native Internal')
    parser.add_argument('--common-commit', default=None,
                        type=str, help='commit to use for Common SDK')
    parser.add_argument('--turf-commit', default=None,
                        type=str, help='commit to use for Turf')

    parser.add_argument('--stable', action='store_true',
                        help='use dependencies from the last release')
    parser.add_argument('--clean', action=argparse.BooleanOptionalAction, default=False,
                        help='clean repositories before checkout')
    parser.add_argument('--private-commit', type=str,
                        help='commit to use for private version of Mapbox Maps iOS. If specified, the private repo will be checked out instead of local public subtree.')

    parser.add_argument('--force-relative-paths', action=argparse.BooleanOptionalAction, help="Replace absolute paths with relative paths in the generated project file. Experimental.")

    args = parser.parse_args()

    # Enter the script folder
    os.chdir(os.path.dirname(os.path.realpath(__file__)))
    # Enter the build folder
    if not os.path.exists("build"):
        os.mkdir("build")
    os.chdir("build")

    if args.private_commit:
        maps_path = "mapbox-maps-ios-private"
        print_phase(f"Checkout Private Mapbox Maps iOS ({maps_path}@{args.private_commit})")
        checkout_repo(maps_path, args.private_commit, clean=args.clean)
    else:
        maps_path = "../../mapbox-maps-ios"
        print_phase(f"Using Public Mapbox Maps iOS from subtree")

    if args.stable:
        with open(f"{maps_path}/scripts/release/packager/versions.json") as f:
            versions = json.load(f)

        if args.gl_native_commit is None:
            args.gl_native_commit = resolve_version(versions["MapboxCoreMaps"], "maps-v")

        if args.turf_commit is None:
            args.turf_commit = resolve_version(versions["Turf"], "")

    # Apply default branches of nothing was set
    if args.gl_native_commit is None:
        args.gl_native_commit = "internal"

    if args.turf_commit is None:
        args.turf_commit = "main"

    # Convert args to human-readable string
    args_str = ""
    for arg in vars(args):
        if getattr(args, arg) is not None:
            args_str += f"\t--{arg} {getattr(args, arg)}\n"

    print_phase("Finalized args: \n" + args_str)

    print_phase(f"Checkout GL Native (@{args.gl_native_commit})")
    checkout_repo("mapbox-gl-native-internal",
                  args.gl_native_commit, checkout_submodules=True, submodules_path="vendor", clean=args.clean)
    # configure project
    os.chdir("mapbox-gl-native-internal")
    if args.common_commit is not None:
        print_phase(f"Checkout custom Common SDK (@{args.common_commit})")
        os.system(f"git -C vendor/common checkout {args.common_commit}")

    os.system("pwd")
    print_phase("Configure GL Native")
    configure_command = """cmake -B build/ios
                            -DBUILD_SHARED_LIBS=OFF
                            -DCMAKE_ARCHIVE_OUTPUT_DIRECTORY="./lib"
                            -DCMAKE_BUILD_TYPE=Release
                            -DCMAKE_OSX_SYSROOT=iphoneos
                            -DCMAKE_SYSTEM_NAME=iOS
                            -DMAPBOX_COMMON_BUILD_TYPE='SHARED'
                            -DMAPBOX_COMMON_TARGET_NAME='MapboxCommon'
                            -DMAPBOX_COMMON_ADD_LIBOUTDIR_TO_FRAMEWORK_SEARCH_PATH=ON
                            -DMAPBOX_ENABLE_FRAMEWORK=ON
                            -DMBGL_WITH_IOS_CCACHE=ON
                            -DMBGL_WITH_METAL=ON
                            -GXcode""".replace("\n", "\\\n")

    print(configure_command)
    os.system(configure_command)

    # xcodegen chokes on the PBXBuildStyle objects in the generated project file.
    # They're a legacy construct, and everything works if you just delete them.
    # https://github.com/tuist/XcodeProj/issues/688
    os.system("sed -i '' '/Begin PBXBuildStyle section/,/End PBXBuildStyle section/d' 'build/ios/Mapbox GL Native.xcodeproj/project.pbxproj'")
    os.chdir("..")

    print_phase(f"Checkout Turf (@{args.turf_commit})")
    checkout_repo("turf-swift", args.turf_commit, clean=args.clean)

    # leave build directory
    os.chdir("..")

    print_phase("Patch GL Native project")
    if args.force_relative_paths:
        patch_flags = "--force-relative-paths"
    else:
        patch_flags = ""

    os.system(f"swift run --package-path tools/PatchGLNativeXCProject patch-cmake-xcproject build/mapbox-gl-native-internal/build/ios/Mapbox\ GL\ Native.xcodeproj {patch_flags}")

    print_phase(f"Create {maps_path}/developer.xcconfig")
    with open(f"build/{maps_path}/developer.xcconfig", "w") as f:
        f.write("SWIFT_TREAT_WARNINGS_AS_ERRORS[config=Release] = NO")

    # Generate Xcode projects
    print_phase("Generate Xcode projects")
    os.system(f"PROJECT={maps_path} xcodegen")

#   # Open the resulting project
    print_phase("Open Xcode project")
    os.system("xed MapboxMaps.xcodeproj")


def checkout_repo(repo_name: str, repo_branch: str, org: str = "mapbox", checkout_submodules=False, submodules_path=None, clean=False):
    # checkout the repo if folder doesn't exist. Otherwise, fetch the latest changes
    os.system("pwd")
    if not os.path.exists(repo_name):
        print("Cloning " + repo_name + "...")
        command = f"git clone --branch {repo_branch} git@github.com:{org}/{repo_name}.git {repo_name}"
        print(command)
        if os.system(command) != 0:
            print("Failed to clone repo with branch rule. Trying again with clone & checkout...")
            command = f"git clone git@github.com:{org}/{repo_name}.git {repo_name} && git -C {repo_name} checkout {repo_branch}"
            print(command)
            os.system(command)
    else:
        print("Fetching latest changes for " + repo_name + "...")
        if clean:
            os.system(f"git -C {repo_name} reset --hard && git -C {repo_name} clean -dffx")
        os.system(f"git -C {repo_name} fetch")
        os.system(f"git -C {repo_name} checkout -f {repo_branch} --")
        os.system(f"git -C {repo_name} pull origin {repo_branch} --rebase --autostash")

    if checkout_submodules:
        print("Checkout submodules for " + repo_name + "...")
        os.chdir(repo_name)
        print("Cleaning submodules...")
        if clean:
            os.system("git submodule foreach --recursive 'git reset --hard && git clean -dffx' > /dev/null")
        if submodules_path is None:
            os.system("git submodule update --init --recursive")
        else:
            os.system("git submodule update --init --recursive " + submodules_path)
        os.chdir("..")


main()
